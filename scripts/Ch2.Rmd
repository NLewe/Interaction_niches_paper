---
title: "Pasture plants employ diverse interaction strategies with AMF "
author: "Natascha Lewe"
output:
  word_document2:
    number_sections: yes
    toc_depth: 3
    reference_docx: bib/Test.docx
bibliography: bib/20220513bib.bibtex
csl: bib/apa.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning  = FALSE)
knitr::opts_chunk$set(dpi  = 300)

#bibliography: 20210813bib_lib_CK.bibtex
#csl: apa.csl


library(tidyverse)
library (flextable)  #https://ardata-fr.github.io/flextable-book/
#library(citr)#when .bib angegeben ist kann man bei addins referencen anwählen
library(knitr)
library(vegan)
library(picante)
library(RColorBrewer)
library(bipartite)
library(readxl)

library(phyloseq)
##Build phylogenetic TREE######
#https://rstudio-pubs-static.s3.#amazonaws.com/345955_fba1ccbdcd8f424aa5505c15bfd75bf7.html
#Lib
library(stats)
library(ade4)
library(ape)
library(adegenet)
library(phangorn)
library(seqinr)
library(msa)
library(microbiome)
library (rstatix)
library(ggpubr)
library(metagMisc)
library(phylosmith)
library (rstatix)
library (factoextra)
library(FactoMineR)
library (MicEco)
library(png)
library (grid)
library (gridExtra)
library(iNEXT)
library (ggrepel)
library (ggradar)
library (scales)
library (edgeR)
library (limma)
library (Glimma)
library (ggtree)
library (car)
library (ggradar)
library (scales)

set.seed(23111406)

#Voraussetzungen für dieses doc sind 
#Marsden0_dada2.R (R in Results Ordner)
#Ergebnisse sind in tabellenformat gespeichert in 

# 
# If certain code chunks in your R Markdown documents are time-consuming to run, you may cache them by adding the chunk option cache = TRUE in the chunk header, and you are recommended to label such code chunks as well, e.g.,{r important-computing, cache=TRUE}


```

# Methods



```{r metrics-table, tab.cap = "Overview of metrics used for the description of the plant-AMF interaction niche. "}

metrics_table <- read_xlsx("dataCh2/metric_table.xlsx")

metrics_table %>%  flextable () %>% 
  theme_vanilla() %>% 
  set_table_properties( layout = "autofit", width =1)
```




\newpage

# Results

```{r ps-data-upload}

#Get ps (prepared, and saved from chunk phyloseq-object)
ps_ALL_0 <- read_rds("dataCh2/ps_ALL.rds")

#meta
 metaM0 <- read_xlsx("dataCh2/meta/M0_meta.xlsx")
## change meta table to short PlaSpe names
sample_data(ps_ALL_0) <- sample_data (metaM0 %>% data.frame (row.names = "sampleID"))

#Use metamMisq for
# ps_ALL_iter <-  phyloseq_coverage_raref(ps_ALL_0, iter =99) #produces 99 ps objects in list
# write_rds (ps_ALL_iter, "results/ps_ALL_iter99.rds")
# ps_ALL_iter <- read_rds("results/ps_ALL_iter99.rds")
# #get mean result of 99 iterations of resampling
# ALL_coverage_tables <-
#   map(ps_ALL_iter, otu_table) %>%
#   map (data.frame) %>%   map (t) %>%
#   map (function (df) as_tibble (df,rownames = "sampleID" )) %>%
#   map_dfr (bind_rows, .id = "TableNumber") %>%
#   pivot_longer(!c(TableNumber, sampleID), names_to =  "ASV_ID", values_to = "counts") %>%
#   group_by (sampleID, ASV_ID) %>% select (!TableNumber) %>% 
#   summarize (mean_counts = ceiling (mean(counts))) %>%
#   unique () %>%
#   pivot_wider(id_cols = , names_from = "sampleID", values_from = "mean_counts") %>%
#   data.frame()
# rownames (ALL_coverage_tables)<- ALL_coverage_tables$ASV_ID
# ALL_coverage_tables <- ALL_coverage_tables[,-1]
# 
# 
# # # get back into ps_ALL as otu_table
# ps_ALL <- ps_ALL_0  # to get a ps_ALL object
# otu_table (ps_ALL) <- otu_table(ALL_coverage_tables, taxa_are_rows = T)


#All fungi####
# ps_Fungi  <- subset_taxa (ps_ALL, Kingdom =="Fungi")  #all fungi selected
# ps_Fungi  <- prune_samples (sample_sums(ps_Fungi)>=1, ps_Fungi)  # samples that are empty after selection of fungi are removed

# get only Glo####
 ps_Glo <- read_rds("resultsCh2/ps_Glo.rds")

# change meta

sample_data (ps_Glo) <- sample_data (metaM0 %>% data.frame (row.names = "sampleID"))
#subset
# ps_Glo  <- subset_taxa(ps_ALL, Phylum == "Glomeromycota")
# ps_Glo  <- prune_taxa(taxa_sums(ps_Glo) >= 1, ps_Glo) # ASVs removed that are 0
# #because some Glo ASVs might be lost some samples might be empty, remove them
# ps_Glo  <- prune_samples(sample_sums(ps_Glo)>=1, ps_Glo)
# 
# # #GET data here instead of 
#  write_rds(ps_Glo, "results/ps_Glo.rds")

#Use presence-absence data only (binary)
ps_bin  <- metagMisc::phyloseq_standardize_otu_abundance (ps_Glo, method = "pa")

#agglomerate all replicates onto one sample, 
#otu_table counts will be reassigned as the mean of all the samples that are merged together. 
ps_bin_PlaSpe <- merge_samples(ps_bin, group = "PlantSpeciesfull") ### gives the sums
 
#total number of all ASVs from sample inference####
No_ASVs  <- ntaxa (ps_ALL_0)


# Glo Table ASVs####
 ASV_table_Glo  <- 
  otu_table (ps_Glo) %>% 
  data.frame() %>%  
   as_tibble (rownames = "ASV_ID") %>%   
   left_join ((tax_table (ps_Glo) %>% data.frame() %>%  as_tibble (rownames = "ASV_ID")), by = "ASV_ID")
  
 #number of ASvs per Glo Family####
 AMF_Fam_ASVs<- 
   ASV_table_Glo  %>%  
   group_by( Family)   %>%  
   tally()  %>%  
   arrange (desc(n))  %>%  
   as.data.frame()
 
 # All ASVs####
 AMF_all_ASVs<- ntaxa (ps_Glo)
 
 ## Percent of Glo Families in dataset (based on reads,####
 #counts per sample (um die % auszurechnen)
 total_counts_per_per_sample  <- 
   ASV_table_Glo  %>%  
   select (-c(Kingdom, Phylum, Class, Order, Genus, Species))  %>%  
   pivot_longer (!c(Family, ASV_ID), names_to = "sampleID", values_to="counts")  %>%  group_by(sampleID)  %>% 
   summarise(total_count=sum(counts)) 
 
 #  TOTAL read count for Glomeromycota ####
Glo_total_counts  <-ASV_table_Glo  %>%  
    select (-c(Kingdom, Phylum, Class, Order, Genus, Species))  %>%  
    pivot_longer (!c(Family, ASV_ID), names_to = "sampleID", values_to="counts")  %>%
   summarize(total=sum(across(counts)))

# relative number of reads per Glo family in whole dataset, in Percent ####
Glo_Fam_perc_reads  <- 
ASV_table_Glo  %>%  
    select (-c(Kingdom, Phylum, Class, Order, Genus, Species))  %>%  
    pivot_longer (!c(Family, ASV_ID), names_to = "sampleID", values_to="counts")  %>%
  group_by (Family)  %>% 
  summarize(Fam_sum=sum(counts)) %>% 
       add_column (Glo_total_counts)  %>% 
  mutate (Glo_Fam_perc = 100  * Fam_sum/total)  %>% 
  arrange(desc(Fam_sum))  %>% 
  as.data.frame()

 #No of removed samples by Glo and rarefying
 rem_samples <- nsamples(ps_ALL_0)-nsamples(ps_Glo)
 #
 richness_ps_ALL_0 <- estimate_richness(ps_ALL_0, measures = "Observed")

```

```{r dada2-results}
df_dada_1  <- read_csv("resultsCh2/dada2_pseudopooling.csv")#das ist der Vergleich der ASV Anzahl von indpendent dada2 und pseudopooling dada2
df_dada_reads <- read_csv("resultsCh2/track_reads_M0_PP.csv") #Tabelle aller Schritte von filtering, merging etc. für independent dada2 sample inference)
PPvsInd_ASVs  <-  df_dada_1    %>%  as_tibble()  %>% 
  group_by(mode) %>% 
  summarise(meanASV=mean(observed),sdASV = sd(observed)) # vergleich der beiden dada2 approaches - pseudopooling versus independent

#Anzahl readsmean
N_reads0 <- df_dada_reads  %>% summarise(all_reads= sum(input))
N_reads <-  df_dada_reads  %>% summarise(all_reads= sum(nonchim))
average_reads0  <- df_dada_reads  %>% summarise(ave_reads= mean(input))
average_reads   <-  df_dada_reads  %>% summarise(ave_reads= mean(nonchim))


```

```{r phyloseq-object}

# #get files#### ---- later, when rarefy needed, we have to use ALL sequences... and then select the Glomeromycota
# #tree####
# #Tree for Glo sequences only#### tree for full dataset is in dada2 script
# #Fasta file with all sequences
# ASV_fasta  <- seqinr::read.fasta(file = "results/ASVs.fa", seqtype = "DNA", as.string = TRUE)
# #Subset fasta file for Glo sequences
# ASV_fasta_Glo  <- ASV_fasta[names(ASV_fasta) %in% ASV_table_Glo$ASV_ID]
# seqinr::write.fasta(ASV_fasta_Glo, names = names(ASV_fasta_Glo), file.out= "results/ASV_fasta_Glo.fa")
# #Import fasta file as dna sequences for later alignment
# dna_Glo   <- readDNAStringSet("results/ASV_fasta_Glo.fa")
# #Alignment with ClustalW###
# ASVs_align_Glo  <-msa(dna_Glo, "ClustalW")
# #Convert for different package, here seqinr
# ASVs_align_Glo_forseqinr  <- msaConvert(ASVs_align_Glo, type= "seqinr::alignment")
# 
# #Build distance matrix as prep for tree###
# d_Glo <- seqinr::dist.alignment(ASVs_align_Glo_forseqinr, "identity")  #seqinr package
# #phylogenetic tree
# #neighbor joining
# ASV_tree_Glo  <- nj(d_Glo)  #ape package
# 
# #check if nJ was appropriate
# # x  <- as.vector(d_Glo)
# # y  <- as.vector(as.dist(cophenetic(ASV_tree_Glo)))
# # 
# # plot (x, y, xlab = "original distance", ylab = "distance in the tree",
# #       main = "Is NJ appropriate?", pch = 20, col = transp("black", 0.1), cex = 3)
# # abline(lm(y ~ x))
# # cor(x, y)^2
# ##when points on line, then fine. looked good enough
# 
# 
# 
# ##Matrix =otu-table herstellen für das Package####
# matrix  <-  ASV_table_Glo  %>%  
#   select(-c(Kingdom, Phylum, Class, Family, Order, Genus, Species))  %>% 
#   as.data.frame() 
# rownames(matrix)  <- matrix$ASV_ID
# matrix  <- matrix[,-1]
# 
# #OTU-table prep
# #here ASV abundances, ASVs in rows, samples in columns, nur GLO
# OTU  <- otu_table(as.matrix(matrix), taxa_are_rows = TRUE) # makes otu_table for phyloseq
# 
# #Sample data 
# # is my meta table 
# sampledata  <- sample_data (data.frame (metaM0, row.names = "sampleID")) ##sampledata for phyloseq
# 
# #taxa 
# # Add taxa data - maybe do as explained for their trait data#
# ##data frame with rows = ASVs, colums = traits (here: taxa names)
# taxa_df_Glo  <-  taxa_table %>%  
#   filter(Phylum=="Glomeromycota")  %>% 
#   select (!Kingdom) %>% 
#   as.data.frame()
# rownames(taxa_df_Glo)  <- taxa_df_Glo$ASV_ID
# TAX  <- tax_table(as.matrix(taxa_df_Glo[,-1])) #taxa table for phyloseq
# 
# #Tree
# #class(ASV_tree_Glo) #is it phylo? Yes, is okay already
# 
# ##Put together into phyloseq object
# ps_Glo  <- phyloseq(OTU, TAX, ASV_tree_Glo, sampledata)


# #Phyloseq_all####
# #OTUtable 
# OTU_ALL  <- otu_table ( ASV_counts, taxa_are_rows =  TRUE) # change to OTU_table object 
# 
# #taxa table
# taxa_test <- as.matrix(read.table("results/ASVs_taxonomy_simple.tsv", header=T,row.names=1, check.names=F, sep="\t")) # load
# TAX_ALL  <- tax_table(gsub(taxa_test[, colnames(taxa_test)],   pattern = "[a-z]__", replacement = ""))
#                 # remove name strings p__ etc with gsub. change to phyloseq taxa table with tax_table ()
# 
# #Sample data 
# # is my meta table 
# sampledata  <- sample_data (data.frame (metaM0, row.names = "sampleID")) ##sampledata for phyloseq

# ##Phyloseqtree for the full dataset here for reload if needed:####
# #
# dna<- readDNAStringSet ("results/ASVs.fa")
# #
# #
# ASVs_align  <-msa(dna, "ClustalW")
# ASVs_align_forseqinr  <- msaConvert(ASVs_align, type= "seqinr::alignment")
# #
### Citing this package
# If you use this package for research that is published later,
#you are kindly asked to cite it as follows:
#   U. Bodenhofer, E. Bonatesta, C. Horejš-Kainrath, and S. Hochreiter (2015).
#msa: an R package for multiple sequence alignment. Bioinformatics 31(24):3997-3999. DOI: 10.1093/bioinformatics/btv494.
 # Moreover, we insist that, any time you use/cite the package,
#you also cite the original paper in which the algorithm/method/package
#that you have been using has been introduced:
#   ClustalW:
#   J. D. Thompson, D. G. Higgins, and T. J. Gibson (1994).CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap
#penalties and weight matrix choice. Nucleic Acids Res., 22(22):4673 4680. DOI: 10.1093/nar/22.22.4673.

# #Build distance matrix as prep for tree
# d <- dist.alignment(ASVs_align_forseqinr, "identity")  #seqinr package
# #tree
# #neighbor joining
# ASV_tree  <- nj(d)  #ape package
# ps_ALL  <- phyloseq(OTU_ALL, TAX_ALL, sampledata, ASV_tree)
# write_rds(ps_ALL, "data/ps_ALL.rds")


```

## Sequence data

The dataset included samples from 20 different plant species from five plant families, and soil samples (Table \@ref(tab:pl-list)). For each plant species and soil, five replicates were procured except for *A. capillaris* (four replicates), *E. repens* (three replicates), *P. cita* (three replicates) and *U. uncinata* (three replicates), for which the missing replicates did not reach harvesting age. 
Consequently, sequencing results for `r nsamples(ps_ALL_0)` samples were obtained with an average of `r round (average_reads0$ave_reads[1]) %>% prettyNum(big.mark = ",")` reads per sample and a total read number of `r round (N_reads0$all_reads[1]) %>%  prettyNum(big.mark = ",")`. 
After filtering, an average of `r round(average_reads$ave_reads[1]) %>% prettyNum(big.mark = ",")` or `r round(average_reads$ave_reads *100 /average_reads0$ave_reads)`% remained of the initial sequencing reads.
The DADA2 pipeline resulted in a total number of `r ntaxa(ps_ALL_0) %>% prettyNum(big.mark = ",")` ASVs, and an average number of `r round(PPvsInd_ASVs$meanASV[2])` $\pm$ `r round(PPvsInd_ASVs$sdASV[2])` ASVs per sample, ranging from `r min (richness_ps_ALL_0)` to `r max (richness_ps_ALL_0)` ASVs across all samples were assigned. 
As samples were rarefied to their minimal coverage, which was at 99.9 % coverage, the average read count declined to `r round (mean (readcount(ps_ALL_0)))%>% prettyNum(big.mark = ",")` per sample. 
ASVs not belonging to the subphylum Glomeromycotina were removed from the data leaving `r AMF_all_ASVs` ASVs with a total count of `r Glo_total_counts$total[1]%>% prettyNum(big.mark = ",")` reads. Of those, `r AMF_Fam_ASVs$n[7]` ASVs, which made up a total `r round (Glo_Fam_perc_reads$Glo_Fam_perc[7], digits=2)` % of the read counts were unidentified at the AMF family level.
This resulted in the removal of `r rem_samples` samples (Table \@ref(tab:pl-list)), in which ASVs belonging to the Glomeromycotina could not be detected. 


```{r pl-list, include = F, tab.cap = "Studied pasture plant species. Of the whole set of species, eleven were from the Poacaea, four species were Asteraceae, followed by two species each from the Fabaceae and Plantaginaceae, and one plant species originated from the Cyperaceae.", tab.id = "pl-list",  label = "pl-list" }

#calculate number of replicates for unique figure and or pl-list table####
#Problem : some plant species have only 2 or 3 replicates- the cumulative ASV number is not comparable, need to normalise it by including the number of the replicates 
#repl after selecting Glo ####
replicates_samples_after_Glo  <-
  ASV_table_Glo  %>% 
    select(-c(Kingdom, Phylum, Class, Family, Order, Genus, Species))  %>% 
    gather (!ASV_ID, key=sampleID, value = ASV_counts)  %>%
    left_join(metaM0, by="sampleID") %>% 
    filter (ASV_counts!=0) %>% 
    group_by (sampleID) %>%  
    tally(name="numberASVs") %>% 
    left_join(metaM0, by="sampleID") %>%  group_by(PlantSpeciesfull) %>%  tally() %>% 
 dplyr:: rename ("repl"= "n")

#repl before selecting Glo####
#use this because samples were only removed because they had 0 Glo, but they count as replicates, too!
replicates_samples_before  <-
    otu_table (ps_ALL_0) %>%  data.frame () %>%  as_tibble (rownames = "ASV_ID") %>% 
    gather (!ASV_ID, key=sampleID, value = ASV_counts)  %>%
    left_join(metaM0, by="sampleID") %>% 
    group_by (sampleID) %>%  
    tally(name="numberASVs") %>% 
    left_join(metaM0, by="sampleID") %>%  group_by(PlantSpeciesfull) %>%  tally() %>% 
    dplyr::rename ("repl"= "n")

## the table of plants ####
meta_plants_ch2 <- read_xlsx("dataCh2/meta/M0_meta.xlsx", sheet = "replicates" ) %>%  select ("Plant species", Abbreviation)


 metaM0 %>% select (!sampleID) %>% 
   select (!filename) %>% unique () %>% 
  left_join (replicates_samples_before, by = "PlantSpeciesfull")  %>% 
  left_join (replicates_samples_after_Glo, by = "PlantSpeciesfull") %>% 
  unique () %>%  
  left_join (meta_plants_ch2, by = c("PlaSpe"= "Abbreviation")) %>% 
   select (-PlantSpeciesfull ) %>% 
   select (!PlaSpe) %>% 
   select (!sortedPlantSpecies) %>% 
   relocate ("Plant species") %>% 
  flextable ()  %>% 
  italic (j = "Plant species") %>% 
  set_header_labels(  PlantFamily = "Plant family" , 
                    repl.x = "Replicates", repl.y = "Replicates with AMF") %>%  
   theme_vanilla() %>%   set_table_properties( width = 1, layout = "autofit") 
# %>%    flextable::footnote (i = 17, j = 1, value = as_paragraph (c("Origin of seeds: nzseeds.co.nz") ))


```


## Plant-AMF interaction niche width

Several numeric and phylogenetic metrics were calculated to capture different aspects of the interaction niche width of the studied plant species regarding their mutualistic interaction with AMF.

### The numeric interaction niche width of the plant species (alpha-diversity)

```{r ASVrichness-calc}

# Richness, a-diversity LINKS PER Species######
#ASV_richness# Table
#mean ASVs per sample####

meannumberASVspersample   <-
 ASV_table_Glo  %>% 
 select(-c(Kingdom, Phylum, Class, Family, Order, Genus, Species))  %>% 
 gather (!ASV_ID, key=sampleID, value = ASV_counts)  %>%
 left_join(metaM0, by="sampleID") %>% 
 filter (ASV_counts!=0) %>% 
 group_by (sampleID) %>%  
 tally(name="numberASVs") %>% 
 left_join(metaM0, by="sampleID") %>% 
 group_by (PlaSpe) %>% 
 mutate(meannumberASVs=mean(numberASVs)) %>% 
 arrange(meannumberASVs) 

#mean ASVs per plant species####
meannumberASVsper_species   <-
 ASV_table_Glo  %>% 
 select(-c(Kingdom, Phylum, Class, Family, Order, Genus, Species))  %>% 
 gather (!ASV_ID, key=sampleID, value = ASV_counts)  %>%
 left_join(metaM0, by="sampleID") %>% 
 filter (ASV_counts!=0) %>% 
 group_by (sampleID) %>%  
 tally(name="numberASVs") %>% 
 left_join(metaM0, by="sampleID") %>% 
 group_by (PlaSpe) %>% 
 mutate(meannumberASVs=mean(numberASVs)) %>% 
 arrange(meannumberASVs)   %>% 
 select (-c(sampleID, numberASVs)) %>% 
 group_by (PlantSpeciesfull, PlantFamily, PlantType)  %>% 
 summarize (mean_n_ASV_per_species  = mean(meannumberASVs))

# total ASVs in dataset####
totalASVs  <-ASV_table_Glo %>%  tally()

# unique ASVs per plant species ####
uniqueASVsperPlaSpe   <-  ASV_table_Glo  %>% 
 select(-c(Kingdom, Phylum, Class, Family, Order, Genus, Species))  %>% 
 gather (!ASV_ID, key=sampleID, value = ASV_counts)  %>%
 left_join(metaM0, by="sampleID") %>% 
 filter (ASV_counts!=0)  %>% 
 group_by(PlantSpeciesfull, ASV_ID)  %>% 
 tally ()  %>% 
 group_by(PlantSpeciesfull)  %>% 
 tally (name ="uniqueASVsperPlSpe")

## Use phyloseq ##

adiv_richness  <- estimate_richness(ps_Glo, measures = c("Observed",  "Shannon", "Chao1")) %>% 
 as_tibble (rownames = "sampleID")

#Add Wilcoxon rank sum test 
adiv_kruskal_ob  <- adiv_richness %>%  
 left_join (metaM0, by = "sampleID")  %>%  
 rstatix::kruskal_test(Observed ~ PlaSpe)

adiv_kruskal_chao  <- adiv_richness %>%
 left_join (metaM0, by = "sampleID")  %>%
 rstatix::kruskal_test(Chao1 ~ PlaSpe)

adiv_kruskal_shannon  <- adiv_richness %>%  
 left_join (metaM0, by = "sampleID")  %>%  
rstatix::kruskal_test(Shannon ~ PlaSpe)

# get values for richnesses , especially min and max value
minmax_Sob  <- adiv_richness %>%  
 left_join(metaM0, by = "sampleID")  %>%  
 group_by (PlaSpe)   %>% 
 summarize (mean = mean (Observed))  %>%  arrange (mean)

# minmax_chao1  <- adiv_richness %>%  
#  left_join(metaM0, by = "sampleID")  %>%  
#  group_by (PlaSpe)   %>% 
#  summarize (mean = mean (Chao1))  %>%  arrange (mean)

minmax_Shannon  <- adiv_richness %>%  
 left_join(metaM0, by = "sampleID")  %>%  
 group_by (PlaSpe)   %>% 
 summarize (mean = mean (Shannon))  %>%  arrange (mean)
```



The AMF species richness S~Ob~ and Shannon's diversity index H' provide a proxy for the numeric interaction niche width of the mycorrhizal association of the respective plant species. 
Both metrics showed the large differences among the AMF community alpha-diversity of the plant species and soil (Figure \@ref(fig:plot-ASVrichness)). 
The mean S~Ob~ differed significantly among the plant species (Kruskal-Wallis $\chi$^2^ = `r round (adiv_kruskal_ob$statistic[1],2)`, df = `r adiv_kruskal_ob$df[1]`, *p* \< 0.001), ranging from `r round(meannumberASVspersample$meannumberASVs[1],1)` for *`r meannumberASVspersample$PlantSpeciesfull[1]`* to `r round(meannumberASVspersample$meannumberASVs[83],1)` for *`r meannumberASVspersample$PlantSpeciesfull[83]`*. 

The Shannon diversity index H' showed a slightly different pattern than S~Ob~  with *P. cita*, for example, having a more even AMF community than other plants of similar or larger S~Ob~, like *L. perenne*. 
Overall, the mean values for H' ranged from `r round(minmax_Shannon$mean[1], 2)` to `r round(minmax_Shannon$mean[21], 2)` and were significantly different among the treatments (Kruskal-Wallis $\chi$^2^ = `r round (adiv_kruskal_shannon$statistic[1],2)`, df = `r adiv_kruskal_shannon$df[1]`, *p* \< 0.001). 
The AMF community of the soil treatment was also included. 
Soil samples had an average of `r round(meannumberASVspersample$meannumberASVs[28],1)` ASVs, which was a greater number than for each plant species in the Asteraceae, Cyperaceae, and Fabaceae. 
On the other end of the spectrum were most species of the Poaceae and the Plantaginaceae, having large mean AMF richness with values around 50 ASVs per species (Figure \@ref(fig:plot-ASVrichness)). 
In contrast, *L. perenne* and the native grass *P. cita* hosted intermediate levels of AMF alpha-diversity, similar to that found in soil samples. 


```{r plot-ASVrichness, include = F, fig.cap= "AMF $\\alpha$-diversity per plant species. Shown are the AMF species richness S, and Shannon's diversity index H'. Horizontal lines show median values, boxes denote the interquartile range (IQR), while whiskers show 1.5*IQR ranges. Outliers are indicated by dots.",   fig.align="center", fig.width=9, fig.height=6}

#Plot richness

p1  <-   adiv_richness %>% 
 left_join(metaM0, by="sampleID") %>% 
 filter (Observed!=0) %>% 
 group_by (PlantSpeciesfull) %>% 
 mutate(meannumberASVs=mean(Observed)) %>% 
  select (sampleID,Observed, Shannon, PlantSpeciesfull, meannumberASVs, PlantFamily)  %>% 
  pivot_longer(cols=c( Observed, Shannon), names_to ="diversity_measure", values_to = "div", values_drop_na = TRUE) %>% 
 arrange(meannumberASVs)   %>% 
 # mutate (diversity_measure = str_replace(diversity_measure, "Observed","Richness S")) %>% 
 #   mutate (diversity_measure = str_replace(diversity_measure, "Shannon","Shannon's H'")) %>% 
   mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control")) %>% 
 ggplot(aes(y=reorder(PlantSpeciesfull, -meannumberASVs), x=div, fill=PlantFamily))  +
 geom_boxplot()  +
  facet_wrap(vars(diversity_measure), scales = "free_x")


p1 +  
stat_summary (fun=mean, geom="point", shape = 23)  +
 xlab("\u03b1-diversity") +
 ylab ("Plant species and soil control") +
 theme_bw () +
 theme(axis.text.y= element_text(family= "sans", face= "italic", size = 11)) +
 theme (axis.text.x=element_text(family= "sans", size = 11), legend.position = "bottom")  +
 theme (axis.title = element_text(family = "sans", size = 13 ),  
        legend.title=element_text(size=12), 
        legend.text=element_text(size=11)) +
 scale_fill_manual(values=c("Asteraceae"= "#edc948" ,"Cyperaceae" ="#5A6351" ,
                            "Fabaceae" = "#f28e2b" , 
                            "Plantaginaceae"= "#4e79a7","Soil control"= "#9c755f",
                            "Poaceae" = "#7F9A65" ), name = "Plant family and soil control") 
#Plot beta diversity among replicates
#β-diversity among AMF communities associated with individual plants.species 
#A) numeric β-diversity illustrating the relative compositional heterogeneity of the AMF communities associated with the plant species. 

comp_units   <- meannumberASVsper_species  %>% 
 left_join(uniqueASVsperPlaSpe)  %>% 
  left_join (replicates_samples_after_Glo) %>% 
 group_by (PlantSpeciesfull) %>% 
 mutate (unique = mean(uniqueASVsperPlSpe)) %>% 
 mutate (CUnits = 5* unique/(mean_n_ASV_per_species*repl)) %>% # repl adjusted for , times 5 to get back to number of 5 replicates 
  mutate ("1-CU" = 1 - CUnits) 



```

### The unique number of AMF species per plant species

The number of unique ASVs per plant species, i.e., their gamma-diversity, is one of several proxies to describe the interaction niche width. 
Fig. \@ref(fig:plot-uniqueASVs-perPlant) shows the cumulative unique ASVs per plant species and soil, sorted by mean species richness. 
The composition of the AMF communities differed among treatments. 
Plant species with small cumulative AMF species values (species von Asteraceae, Cyperaceae and Fabaceae) showed highly variable AMF community compositions, while members of the Poaceae and Plantaginaceae had similar compositions of the AMF genera, with some exceptions. 
The AMF genus *Cetraspora*, for example, could only be detected in three plant species; *P. cita*, *S. arundinaceus* and *E. repens*, all of which hosted small numbers of unique ASVs in small relative abundances (Fig. S \@ref(fig:plot-. 
In contrast, the AMF genus *Acaulospora* dominated the community, in terms of relative abundance in *L. perenne* and *P. pratense*, but could not be detected in *P. cita*, *S. arundinaceus*, *A. pratensis*, or *E. repens*. The genera *Archaespora* and *Claroideoglomus* were a proportionally dominant component of the AMF community in most members of the Poacaea and Plantaginaceae, and the highest number of unique ASVs were detected for the *Archaeospora* in these two plant families. Notable also was the even composition of the AMF genera in *P. cita* and in soil, which was also corroborated by their comparably high Shannon's diversity H' (Fig. \@ref(fig:plot-ASVrichness)). Furthermore, *P. cita* and *A. millefolium* hosted a significantly higher proportion of AMF from the genus *Glomus* than the other plant species.

```{r plot-uniqueASVs-perPlant, include = F, fig.cap = "Distribution of AMF genera per treatment. Absolute number of unique ASVs per AMF genus and treatment ($\\gamma$-diversity). Note the different number of replicates for A. capillaris (4), E. repens (3), P. cita (3) and U. uncinata (3). ", fig.height= 6, fig.width=10}



#Plot unique ASVs per plant####
  # Verteilung der Glo genera per plant species 
p1  <-  ASV_table_Glo  %>%  
    select(-c(Kingdom, Phylum, Class, Order, Species))  %>% 
    gather (-c(ASV_ID, Genus, Family), key=sampleID, value = ASV_counts)  %>%
    left_join(metaM0, by="sampleID") %>% 
    filter (ASV_counts!=0)  %>% 
    group_by (ASV_ID, PlantSpeciesfull, Genus) %>% 
    tally () %>%
    group_by(Genus, PlantSpeciesfull )  %>% 
    tally () %>% 
  replace_na(list (Genus="unidentified"))   %>% 
    left_join (meannumberASVsper_species, by = "PlantSpeciesfull")  %>% 
    ggplot (aes(x=reorder (PlantSpeciesfull,-mean_n_ASV_per_species), y= n, fill=Genus))  +
    geom_bar(position="stack", stat ="identity") 

p1<-
  p1+ theme_light()+ 
  coord_flip () +
  ylab("Unique AMF ASVs per plant species") +
  xlab ("Plant species") +
  theme_light () +
  theme(axis.text.y= element_text(family= "sans", face= "italic", size = 12)) +
  theme (axis.text.x=element_text(family= "sans", size = 12))  +
  theme (axis.title = element_text(family = "sans", size = 14 ),  
         legend.title=element_text(size=13), 
         legend.text=element_text(size=11, face ="italic")) +
    scale_fill_manual(values = c( "unidentified" ="#C7EAE5", "Archaeospora"  = "#287D8EFF" , 
                                  "Acaulospora" =  "#C1A363" , 
                                  "Funneliformis" = "#F6E8C3", "Cetraspora"  = "#DFC27D", 
                                  "Claroideoglomus" =  "#20A386FF", 
                                  "Glomus" = "#80CDC1" , "Paraglomus" = "#35978F", 
                                  "Scutellospora"= "#01665E" ), name = "AMF genus"    )  
#   p2   <- 
#   ASV_table_Glo   %>%   
#   select(-c(Kingdom, Phylum, Class, Order, Species, Family))  %>% 
#   gather (-c(ASV_ID, Genus), key=sampleID, value = ASV_counts)  %>%
#   group_by (sampleID, Genus)  %>% 
#   summarise (ASV_sum_per_sample = sum(ASV_counts)) %>% 
# replace_na(list (Genus="unidentified"))   %>% 
#   left_join (metaM0, by = "sampleID")  %>% 
#   group_by (PlantSpeciesfull, Genus)  %>% 
#   summarise (mean_ASV_count_per_species = mean (ASV_sum_per_sample))  %>% 
#   left_join (meannumberASVsper_species, by = "PlantSpeciesfull")  %>% 
#   ggplot (aes(x=reorder (PlantSpeciesfull,-mean_n_ASV_per_species), 
#               y= mean_ASV_count_per_species, fill=Genus))  +
#   geom_bar(position="fill", stat ="identity") 
# 
# p2  <- 
#   p2 + coord_flip () +
#   ylab("Relative abundance of ASV reads (%)") +
#   theme_light () +
#   theme(axis.text.y= element_text(family= "sans", face= "italic", size = 12)) +
#  theme (axis.text.x=element_text(family= "sans", size = 12))  +
#   theme (axis.title = element_text(family = "sans", size = 14 ),  
#          legend.title=element_text(size=13), 
#          legend.text=element_text(size=11, face = "italic"),
#          axis.title.y = element_blank()) +
#   scale_fill_manual(values = c( "unidentified" ="#C7EAE5", "Archaeospora"  = "#287D8EFF" , 
#                                 "Acaulospora" =  "#C1A363" , 
#                                 "Funneliformis" = "#F6E8C3", "Cetraspora"  = "#DFC27D", 
#                                 "Claroideoglomus" =  "#20A386FF", 
#                                 "Glomus" = "#80CDC1" , "Paraglomus" = "#35978F", 
#                                 "Scutellospora"= "#01665E" ) , name = "AMF genus"   )  +
#   scale_y_continuous(labels = scales::percent)+
#   scale_x_discrete(labels = NULL)

# ggarrange (p1,NULL, p2, labels = c("A","B", ""), nrow = 1, ncol =3, widths =  c(2,0.07,1.2), legend = "bottom", common.legend = T)

p1
  
```

### A phylogenetic view of the plants' interaction niche width

```{r PD-phylogenetic distances}


#Standardised PD####


#make df for Glo data (empty samples samples pruned )
comm_df_Glo  <- data.frame (t(otu_table (ps_Glo))) # vegan expects samples as rows and ASVs species as columns

#hier total randomised community data frame as null model
stand_pd_Glo_all  <- as_tibble (ses.pd(comm_df_Glo, phy_tree(ps_Glo), include.root = FALSE, null.model = "independentswap", runs=100, iterations=999), rownames="sampleID")

#In addition, the observed and standardised Faith's PD~PlaSpe~ were calculated for each plant species after agglomeration of the individual samples into one sample per plant species. Comparison of the agglomerated Faith's PD PlaSpe and Faith's PD I reveal ... yeah, the same as in ordination actually.

#agglomerate to Plant Species
ps_Glo_perPlaSpe  <- merge_samples(ps_Glo, group = "PlantSpeciesfull")

#make df for Glo_PlaSpe data (empty samples samples pruned )
comm_df_Glo_PlaSpe  <- data.frame (otu_table (ps_Glo_perPlaSpe)) # vegan expects samples as rows and ASVs species as columns

stand_pd_Glo_PlaSpe  <- as_tibble (ses.pd(comm_df_Glo_PlaSpe, phy_tree(ps_Glo), include.root = FALSE, null.model = "independentswap", runs=1000, iterations=999), rownames="sampleID")


```

Faith's phylogenetic diversity (PD) values varied from `r round (min(stand_pd_Glo_all$pd.obs, na.rm =T),2)` to `r round (max(stand_pd_Glo_all$pd.obs, na.rm =T),2)` (Fig. \@ref(fig:plot-PD)) and mean PD values were similar in pattern to the numeric diversity values (Fig. \@ref(fig:plot-ASVrichness)) with some exceptions. 
For example, soil had a higher PD than would be expected from its numeric richness S~Ob~. Overall, the Asteraceae, Cyperaceae and Fabaceae showed similarly small mean PD values in comparison to the Plantaginaceae and Poaceae, which were higher. 
The mean z-score of the PD differed notably from the pattern of the mean PD, and most samples' AMF communities were not significantly different from randomised AMF communities, indicating that most plant species hosted communities of intermediate phylogenetic richness (Table \@ref(tab:pd-table1)). 
However, after merging of the replicates per treatment, the resulting z-scores can be interpreted as indicator for the within-treatment phylogenetic similarity of the AMF communities (Table \@ref(tab:pd-table2)). 
This revealed that, contrary to Hypothesis 1, the grasses did not show less filtering of their AMF community than the forbs. Instead, several of the plant species studied from the Poaceae hosted AMF communities that were significant different from randomly assembled ones.
For example, individual *D. glomerata* plants seemed to host very similar AMF communities with a z-score~PD~ of `r round (stand_pd_Glo_PlaSpe$pd.obs.z[8], 2)` (*p* = `r round (stand_pd_Glo_PlaSpe$pd.obs.p[8], 2)`), as do *C. vulgare* (z-score~PD~ = `r round (stand_pd_Glo_PlaSpe$pd.obs.z[7], 2)`, *p* = `r round (stand_pd_Glo_PlaSpe$pd.obs.p[7], 2)`), *A. pratensis* (z-score~PD~ = `r round (stand_pd_Glo_PlaSpe$pd.obs.z[3], 2)`, *p* = `r round (stand_pd_Glo_PlaSpe$pd.obs.p[3], 2)`), *L. perenne* (z-score~PD~ = `r round (stand_pd_Glo_PlaSpe$pd.obs.z[12], 2)`, *p* = `r round (stand_pd_Glo_PlaSpe$pd.obs.p[12], 2)`), *H. lanatus* (z-score~PD~ = `r round (stand_pd_Glo_PlaSpe$pd.obs.z[10], 2)`, *p* = `r round (stand_pd_Glo_PlaSpe$pd.obs.p[10], 2)`), and *E. repens* (z-score~PD~ = `r round (stand_pd_Glo_PlaSpe$pd.obs.z[9], 2)`, *p* = `r round (stand_pd_Glo_PlaSpe$pd.obs.p[9], 2)`). 
In contrast to the plant species having hosted AMF communities of lower phylogenetic richness than expected from a random assembled community, the soil AMF community had a positive z-score~PD~ of `r round (stand_pd_Glo_PlaSpe$pd.obs.z[19], 2)`, indicating high phylogenetic richness of the AMF community (non-significant).

```{r plot-PD, fig.cap="Faith's phylogenetic diversity (PD). A) PD by plant species. B) PD effect size (z-score~PD~). Black squares denote PD of the treatment based on merged replicates, for which only significant results are shown based on a comparison of observed PD against PD from randomised communities. Horizontal lines show median values, empty squares show means, boxes denote the interquartile range (IQR), while whiskers show 1.5*IQR ranges. Outliers are indicated by dots.", fig.height= 6, fig.width=10}

p1  <-stand_pd_Glo_all  %>% 
  left_join (metaM0, by= "sampleID")  %>% 
  filter (!is.na(pd.obs)) %>% 
  group_by (PlaSpe) %>% 
  mutate(mean_pd.obs =mean(pd.obs)) %>% 
  arrange(mean_pd.obs)   %>% 
  left_join ((meannumberASVsper_species %>% ungroup () %>% select (-PlantFamily, PlantSpeciesfull, mean_n_ASV_per_species)), by = "PlantSpeciesfull")  %>% 
     mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control")) %>% 
  ggplot (aes(x=reorder (PlantSpeciesfull,-mean_n_ASV_per_species),
             y=pd.obs, fill=PlantFamily))  +
  geom_boxplot() #  +   geom_point (data = (stand_pd_Glo_PlaSpe %>%  left_join(metaM0, by= c("sampleID"= "PlantSpeciesfull"))), aes (x= sampleID, y =pd.obs ), shape = 15)
#that are single points to see 
p1  <- p1 +coord_flip () +
  stat_summary (fun=mean, geom="point", shape = 23)  +
  ylab("Faith's phylogenetic diversity") +
  xlab ("Plant species") +
  theme_light () +
  theme(axis.text.y= element_text(family= "sans", face= "italic", size = 12)) +
  theme (axis.text.x=element_text(family= "sans", size = 12))  +
  theme (axis.title = element_text(family = "sans", size = 14 ),  
         legend.title=element_text(size=13), 
         legend.text=element_text(size=11)) +
  scale_fill_manual(values=c("Asteraceae"= "#edc948" ,"Cyperaceae" ="#5A6351" ,
                             "Fabaceae" = "#f28e2b" , 
                             "Plantaginaceae"= "#4e79a7","Soil control"= "#9c755f",
                             "Poaceae" = "#7F9A65" ), name = "Plant family") 
#Plot Faiths PD-mean effect size####
p2  <-  stand_pd_Glo_all %>% 
  left_join (metaM0, by= "sampleID")  %>% 
  filter (!is.na(pd.obs.z)) %>% 
  group_by (PlaSpe) %>% 
  mutate(mean_pd.obs.z =mean(pd.obs.z)) %>% 
  #arrange(mean_pd.obs.z)   %>% 
  left_join ((meannumberASVsper_species %>% ungroup () %>% 
                select (-PlantFamily, PlantSpeciesfull, mean_n_ASV_per_species)), by = "PlantSpeciesfull")  %>% #to sort like in richness plot
       mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control")) %>% 
  ggplot (aes(x=reorder (PlantSpeciesfull,-mean_n_ASV_per_species), 
             y=pd.obs.z, fill=PlantFamily))  +  
  geom_boxplot() +
    geom_point (data = (stand_pd_Glo_PlaSpe %>% 
                          left_join (metaM0, by= c("sampleID" = "PlantSpeciesfull")) %>% 
                          filter (!between (pd.obs.p, 0.05, 0.95))%>% 
                          select (sampleID, PlantFamily, pd.obs.z)  %>% unique ()),
                aes(x=sampleID, y= pd.obs.z), shape = 15, size =3) 


p2 <- p2  +coord_flip () +
  stat_summary (fun=mean, geom="point", shape = 23)  +
  ylab("Faith's PD effect size (z-score)") +
 # xlab ("Plant Species") +
  theme_light () +
  theme(axis.text.y= element_text(family= "sans", face= "italic", size = 12)) +
  theme (axis.text.x=element_text(family= "sans", size = 12))  +
  theme (axis.title = element_text(family = "sans", size = 14 ),  
         legend.title=element_text(size=13), 
         legend.text=element_text(size=11), 
         axis.title.y = element_blank()) +
  scale_fill_manual(values=c("Asteraceae"= "#edc948" ,"Cyperaceae" ="#5A6351" ,
                             "Fabaceae" = "#f28e2b" , 
                             "Plantaginaceae"= "#4e79a7","Soil control"= "#9c755f",
                             "Poaceae" = "#7F9A65" ), name = "Plant family") +
  scale_x_discrete(labels = NULL)

ggarrange (NULL,p1,NULL,  p2, labels = c("","A","", "B"), hjust = 0.4, nrow = 1, ncol =4, widths =  c(0.05,1.8, 0.05,1), legend = "bottom", common.legend = T)


```


```{r MPD-sample-vs-PlaSpe}
dist_Glo  <- cophenetic(phy_tree(ps_Glo))
ses.MPD_Glo  <-  as_tibble (ses.mpd (comm_df_Glo, dist_Glo, null.model = "independentswap" ), rownames = "sampleID")

#agglomerate to Plant Species
ps_Glo_perPlaSpe  <- merge_samples(ps_Glo, group = "PlantSpeciesfull")

#make df for Glo_PlaSpe data (empty samples samples pruned )
comm_df_Glo_PlaSpe  <- data.frame (otu_table (ps_Glo_perPlaSpe)) # vegan expects samples as rows and ASVs species as columns

ses.MPD_Glo_PlaSpe  <-  as_tibble (ses.mpd (comm_df_Glo_PlaSpe, dist_Glo, null.model = "independentswap" ), rownames = "sampleID")# tree is the same as before

  
```


The mean phylogenetic distance (MPD) of the AMF communities from the Poaceae and Plantaginaceae were similar in their mean values, whereas the other plants had more variable values (Fig. \@ref(fig:plot-MPD)). 
Most of the treatments had AMF communities which were not significantly different from their randomised communities (Table \@ref(tab:mpd-table1)). 
Merging the replicates of each treatment into a single sample and calculating the z-score resulted in three species with significant negative z-score values, indicating that these plants hosted conserved AMF communities (Table \@ref(tab:mpd-table2)): *D. glomerata* (z-score~MPD~ = `r round (ses.MPD_Glo_PlaSpe$mpd.obs.z[8], 2)`, *p* = `r round (ses.MPD_Glo_PlaSpe$mpd.obs.p[8], 2)`), *A. millefolium* (z-score~MPD~ = `r round (ses.MPD_Glo_PlaSpe$mpd.obs.z[2], 2)`, *p* = `r round (ses.MPD_Glo_PlaSpe$mpd.obs.p[2], 2)`) and *H. lanatus* (z-score~MPD~ = `r round (ses.MPD_Glo_PlaSpe$mpd.obs.z[10], 2)`, *p* = `r round (ses.MPD_Glo_PlaSpe$mpd.obs.p[10], 2)`). In contrast, *P. pratense* and *B. willdenowii* had, with values of `r round (ses.MPD_Glo_PlaSpe$mpd.obs.z[17], 2)` (*p* = `r round (ses.MPD_Glo_PlaSpe$mpd.obs.p[17], 2)`) and `r round (ses.MPD_Glo_PlaSpe$mpd.obs.z[4], 2)` (*p* = `r round (ses.MPD_Glo_PlaSpe$mpd.obs.p[4], 2)`) respectively, over-dispersed AMF communities.


```{r plot-MPD, fig.cap= "Mean phylogenetic distances (MPD). A) MPD per treatment.  B) MPD effect size (z-score~MPD~). Black squares denote MPD of the treatment based on merged replicates, for which only significant results are shown based on a comparison of observed MPD against MPD from randomised communities. Test results can be found in the appendix. Horizontal lines show median values, empty squares show means, boxes denote the interquartile range (IQR), while whiskers show 1.5*IQR ranges. Outliers are indicated by dots. ", fig.height=6, fig.width=10}


#Plot MPD####
p1   <- 
  ses.MPD_Glo  %>% 
left_join (metaM0, by= "sampleID")  %>% 
  filter (!is.na(mpd.obs)) %>% 
  group_by (PlaSpe) %>% 
  mutate(mean_mpd.obs =mean(mpd.obs)) %>% 
  arrange(mean_mpd.obs)   %>% 
  left_join ((meannumberASVsper_species %>% ungroup () %>%
                select (-PlantFamily, PlantSpeciesfull, mean_n_ASV_per_species)), by = "PlantSpeciesfull")  %>% 
       mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control")) %>% 
  ggplot (aes(x=reorder (PlantSpeciesfull,-mean_n_ASV_per_species),
             y=mpd.obs, fill=PlantFamily))  +
  geom_boxplot() 
#+geom_point (data = (ses.MPD_Glo_PlaSpe %>% left_join (metaM0, by= c("sampleID" = "PlantSpeciesfull"))), aes(x=sampleID, y= mpd.obs), shape = 15)
#small numbers are generalists here!

p1  <- p1 +coord_flip () +
  stat_summary (fun=mean, geom="point", shape = 23)  +
  ylab("Mean phylogenetic distance (MPD)") +
  xlab ("Plant species") +
  theme_light () +
 theme(axis.text.y= element_text(family= "sans", face= "italic", size = 12)) +
  theme (axis.text.x=element_text(family= "sans", size = 12))  +
  theme (axis.title = element_text(family = "sans", size = 14),  
         legend.title=element_text(size=13), 
         legend.text=element_text(size=11)) +
  scale_fill_manual(values=c("Asteraceae"= "#edc948" ,"Cyperaceae" ="#5A6351" ,
                             "Fabaceae" = "#f28e2b" , 
                             "Plantaginaceae"= "#4e79a7","Soil control"= "#9c755f",
                    "Poaceae" = "#7F9A65" ), name = "Plant family") 
  
   #Plot effect size    ####    
p2   <- 
  ses.MPD_Glo  %>% 
left_join (metaM0, by= "sampleID")  %>% 
  filter (!is.na(mpd.obs)) %>% 
  group_by (PlaSpe) %>% 
  mutate(mean_mpd.obs.z =mean(mpd.obs.z)) %>% 
  arrange(mean_mpd.obs.z)   %>% 
  left_join ((meannumberASVsper_species %>% ungroup () %>%
                select (-PlantFamily, PlantSpeciesfull, mean_n_ASV_per_species)), by = "PlantSpeciesfull")  %>% 
       mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control")) %>% 
  ggplot (aes(x=reorder (PlantSpeciesfull,-mean_n_ASV_per_species),
             y=mpd.obs.z, fill=PlantFamily))  +
  geom_boxplot()  +
    geom_point (data = (ses.MPD_Glo_PlaSpe %>% 
                          left_join (metaM0, by= c("sampleID" = "PlantSpeciesfull")) %>% 
                          filter (! between(mpd.obs.p, 0.05, 0.95))), 
                aes(x=sampleID, y= mpd.obs.z), shape = 15, size =3)

#small numbers are generalists here!

p2  <- p2 +coord_flip () +
  stat_summary (fun=mean, geom="point", shape = 23)  +
  ylab("MPD effect size (z-score)") +
 # xlab ("Plant Species") +
  theme_light () +
 theme(axis.text.y= element_text(family= "sans", face= "italic", size = 12)) +
  theme (axis.text.x=element_text(family= "sans", size = 12))  +
  theme (axis.title = element_text(family = "sans", size = 14 ),  
         legend.title=element_text(size=13), 
         legend.text=element_text(size=11), 
         axis.title.y = element_blank()) +
  scale_fill_manual(values=c("Asteraceae"= "#edc948" ,"Cyperaceae" ="#5A6351" ,
                             "Fabaceae" = "#f28e2b" , 
                             "Plantaginaceae"= "#4e79a7","Soil control"= "#9c755f",
                             "Poaceae" = "#7F9A65" ),name = "Plant family") +
  scale_x_discrete(labels =NULL)




ggarrange (NULL,p1,NULL,  p2, labels = c("","A","", "B"), hjust = 0.4, nrow = 1, ncol =4, widths =  c(0.05,1.8, 0.05,1), legend = "bottom", common.legend = T)


# independentswap  - to compare if the PD of the sample is different from a random PD of the same richness - 
# Randomize community data matrix with the independent swap algorithm (Gotelli 2000) maintaining species occurrence frequency and sample species richness
#phylogeny.pool
#Randomize community data matrix by drawing species from pool of species occurring in the phylogeny (phylogeny pool) with equal probability

```


### beta-diversities of the AMF communities

The percentage of the core AMF species, i.e., the species occurring in at least 60 % of the samples per treatment, indicates the variability of AMF among replicates of each treatment (Table \@ref(tab:specialisation)). Soil had the greatest beta-diversity, only 33 % of its total AMF species were core species, whereas several plant species reached values up to 100 %, indicating very low variability among individuals (replicates) within a species (treatment). A notable exception among the Poaceae was *P. cita* with \~94 % core species in comparison to values located between \~42 % and \~65 % core species for other members of the Poaceae.
While the core species metric beta~core~ was based on the identity of the species, the compositional units (CU) indicate numeric variability among the treatments. The values for CU reached from 2.2 to 5.0 and did not show a clear pattern for the plant species of each plant family. Several plant species (*L. autumnalis*, *M. sativa*, *T. pratense*) showed the highest possible numeric variability of 5, followed by *U. uncinata* and *C. vulgare* with 4.5 CUs. Notable was the high true beta-diversity for soil and for *P. cita*. 
Interestingly, the numeric variability did not show the same pattern as the variability based on the AMF identity (beta~core~). *E. repens* and *P. cita*, for example, had the same numeric variability, but were very different in their percentages of core species. *H. lanatus* had with a value of 2.2 CU the lowest true beta-diversity.

```{r specialisation,  tab.cap = "$\\beta$-diversity of AMF communities per treatment. Percentage of AMF core species of total AMF species per treatment ($\\beta$~core~ in %), and compositional units (CU) per treatment, a measure of true $\\beta$-diversity, adjusted to the number of replicates per treatment. Values of CU can range between 1 and 5.", tab.id ="specialisation", label = "specialisation"}

#Specialisation

# taxa core
ps_Glo_core  <-phylosmith::taxa_core (ps_Glo, treatment = "PlaSpe", frequency =0.6)#see above
ps_core_PlaSpe  <- merge_samples(ps_Glo_core, group = "PlantSpeciesfull", fun = sum)

#calculate beta diversity as percentage 
cores  <- 
  as.data.frame (otu_table (ps_core_PlaSpe )) %>%   as_tibble(rownames = "PlantSpeciesfull") %>% 
  pivot_longer (!PlantSpeciesfull, names_to="ASV_ID", values_to  = "ASV_counts")  %>%  
  group_by (PlantSpeciesfull) %>%  
  dplyr::filter (ASV_counts != "0")  %>% 
  dplyr::tally(name="core") %>% 
  left_join(uniqueASVsperPlaSpe)  %>% 
  mutate (perc_core = 100* core/uniqueASVsperPlSpe) %>% 
  mutate (perc_core = round (perc_core,1) ) %>% 
  select (PlantSpeciesfull, perc_core)

cores %>% 
  left_join(comp_units %>% mutate (CU = round(CUnits,1)), by = "PlantSpeciesfull") %>%
  arrange (mean_n_ASV_per_species) %>% 
  select (PlantSpeciesfull, perc_core,CU) %>% 
  flextable () %>% 
 set_header_labels(PlantSpeciesfull = "Treatment", perc_core ="core AMF species in %") %>%  
  italic (j = "PlantSpeciesfull")  %>% autofit ()


# betas <-unlist (bluthgens_d$dprime) %>% 
#   as_tibble(rownames = "Treatment")  %>%  
#   mutate ("Blüthgens d'" = round (value, 2)) %>%  
#   select (!value) %>%  
#   left_join(cores, by = c("Treatment"= "PlantSpeciesfull")) %>% 
#   mutate (perc_core = round (perc_core,3) )

```

```{r AMFgeneralists, include = F, tab.cap =  "Distribution of AMF families in all 21 treatments.", tab.id = "AMFgeneralists", label =  "AMFgeneralists"}

#bipartite indeces####
##Matrix herstellen für das Package####
matrix  <-  ASV_table_Glo  %>%  
  select(-c(Kingdom, Phylum, Class, Family, Order, Genus, Species))  %>% 
  as.data.frame() 
rownames(matrix)  <- matrix$ASV_ID
matrix  <- matrix[,-1]

# Species degree per sample#####
species_degree  <-  specieslevel(matrix, index="degree")

#AMF ASVS generalists table#####
number_AMF_ASV_generalists  <-
  species_degree$`lower level`  %>% 
  arrange (desc(degree))  %>% 
  filter (degree>29) %>%
  tally()

Table_AMF_species_degree  <-
  species_degree$`lower level`  %>% 
  arrange (desc(degree))  %>% 
  filter (degree>29) %>% 
  as_tibble(rownames="ASV_ID") %>% 
  inner_join(tax_table (ps_Glo) %>% data.frame() %>% as_tibble (rownames= "ASV_ID"), by="ASV_ID")  %>% 
  select (c(ASV_ID, degree, Family, Genus, Species)) %>% 
  dplyr::rename("Species degree" = "degree", "ASV ID" = "ASV_ID")


#AMF Families verteilung in allen Plant species#####
Table_AMF_families_speciesDegree_per_PlantSpecies  <-
  ASV_table_Glo  %>%
select(-c(Kingdom, Phylum, Class, Order, Species))  %>%
gather (-c(ASV_ID, Genus, Family), key=sampleID, value = ASV_counts)  %>%
left_join(metaM0, by="sampleID")  %>% 
  filter (ASV_counts!=0)  %>% 
  group_by (Family, PlantSpeciesfull) %>% dplyr::count() %>% 
group_by(Family)  %>% dplyr::count()%>% 
   dplyr::rename("Number of treatments" = n) %>% filter (!is.na(Family)) %>% 
  flextable () 

Table_AMF_families_speciesDegree_per_PlantSpecies





```

### Synopsis of measures of plant-AMF interaction niche width using principal component analysis (PCA)






```{r plot-PCA-all-metrics, fig.cap = "Principal component analysis (PCA) of numeric and phylogenetic $\\alpha$- and $\\beta$-diversities per treatment. A) PCA-biplot. Dots are treatments, arrows are metrics of diversity. contrib= contribution of variable to placement of treatment in biplot. B)-D) Contributions of metrics to the first three principal components (PC). PD = Faith's phylogenetic diversity, unique = number of unique ASVs per treatment ($\\gamma$-diversity), $\\beta$~core~ = percentage of AMF species occurring in 60% of replicates per treatment, MPD = mean phylogenetic distance, CU = compositional units (true $\\beta$-diversity), Chao1 = Chao1 diversity, Shannon = Shannon's diversity H', Richness = species richness S.", fig.height=8, fig.width=10}

#Get values for all metrics in one tibble#####
All_metrics  <-
  adiv_richness %>% 
  left_join(metaM0)  %>%  
  group_by(PlantSpeciesfull)  %>% 
  #mutate (Chao1 = mean (Chao1)) %>% 
  mutate (Shannon = mean (Shannon)) %>%  
  select (sampleID, Shannon) %>% ## chao1
  select (!sampleID) %>% 
  unique()  %>%  
  left_join (comp_units %>% select (!repl) %>% select (!"1-CU")) %>%   #includes CU and unique and richness
  left_join(cores) %>% 
  select (!c(PlantType,uniqueASVsperPlSpe, PlantFamily))  %>% 
  left_join (stand_pd_Glo_all %>% 
               left_join(ses.MPD_Glo, by ="sampleID")  %>%  
               left_join (metaM0)  %>% 
              drop_na ()  %>% 
                group_by (PlantSpeciesfull)  %>%   
               mutate (mean_pd = mean (pd.obs), mean_mpd = mean (mpd.obs)) %>%  
               select (PlantSpeciesfull,   mean_pd, mean_mpd,PlantFamily)   %>% 
               unique ()  )  %>% 
  dplyr::rename("Richness"= "mean_n_ASV_per_species", "CU" = "CUnits", "β(core)"  = "perc_core",
                 "PD" = "mean_pd", "MPD" = "mean_mpd" )  %>% 
  as.data.frame(row.names = NULL)

rownames(All_metrics)  <- All_metrics$PlantSpeciesfull
All_metrics  <- All_metrics[,-1]

### only the 8 species: 
All_metrics_M0_8Sp  <-
meta_plants %>%  
  select (PlantSpeciesfull) %>% 
  filter (PlantSpeciesfull != "soil")  %>% 
  left_join (adiv_richness %>% 
  left_join(metaM0)  %>%  
  group_by(PlantSpeciesfull)  %>% 
  #mutate (Chao1 = mean (Chao1)) %>% 
  mutate (Shannon = mean (Shannon)) %>%  
  select (sampleID, Shannon) %>% ## chao1
  select (!sampleID) %>% 
  unique() )  %>%  
  left_join (comp_units %>% select (!repl) %>% select (!"1-CU")) %>%   #includes CU and unique and richness
  left_join(cores) %>% 
  select (!c(PlantType,uniqueASVsperPlSpe, PlantFamily))  %>% 
  left_join (stand_pd_Glo_all %>% 
               left_join(ses.MPD_Glo, by ="sampleID")  %>%  
               left_join (metaM0)  %>% 
              drop_na ()  %>% 
                group_by (PlantSpeciesfull)  %>%   
               mutate (mean_pd = mean (pd.obs), mean_mpd = mean (mpd.obs)) %>%  
               select (PlantSpeciesfull,   mean_pd, mean_mpd,PlantFamily)   %>% 
               unique ()  )  %>% 
  dplyr::rename("Richness"= "mean_n_ASV_per_species", "CU" = "CUnits", "β(core)"  = "perc_core",
                 "PD" = "mean_pd", "MPD" = "mean_mpd" ) 


#  Who are the generalists?
scaled_metrics  <-
  All_metrics %>%  
  as_tibble (rownames =  "tm") %>%  
  mutate_at (c(2:8), scale) %>% 
  mutate (b_core = `β(core)`[,1] * (-1)) %>%   ###??????
  select (!(`β(core)`)) %>% 
  pivot_longer(cols = c(2:7,9), values_to = "valueINP", names_to = "metric") %>% 
  ggplot(aes(x= tm, y=metric))  +
  geom_point (aes(size=valueINP, color = valueINP)) +
  coord_flip() +
  scale_color_gradient2(low = "#f90025", mid= "#d0bbb8", high = "#689178", na.value="#89e1ff") +
  ylab("Diversity metric") +
  xlab ("Plant Species") +
  theme_light () +
  theme(axis.text.y= element_text(family= "sans", face= "italic", size = 11)) +
  theme (axis.text.x=element_text(family= "sans", size = 11))  +
  theme (axis.title = element_text(family = "sans", size = 13 ),  
         legend.title=element_text(size=12), 
         legend.text=element_text(size=11))

#PCA ####
#PCA_all_metrics  <- vegan::rda (All_metrics, scale = T)
PCA_all_metrics <- PCA(All_metrics, quali.sup = 9,   scale.unit = T, graph = F)

PCA_arrows_metrics<-
  PCA_all_metrics$var$coord %>%  
  as_tibble (rownames = "metric") %>% 
  dplyr::rename("D1end" = "Dim.1", "D2end"= "Dim.2")

PCA_metric_data   <- PCA_all_metrics$ind$coord  %>%  as_tibble(rownames = "PlantSpeciesfull") %>% 
  left_join(metaM0 %>%  select (PlantSpeciesfull, PlantFamily) %>%  unique ())

PCA_eig_m_Dim1 <- round (PCA_all_metrics$eig[1,2],1)

PCA_eig_m_Dim2 <- round (PCA_all_metrics$eig[2,2],1)
#Plot 

plotPca  <- 
  PCA_metric_data %>%  
     mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control")) %>% 
    ggplot (aes (x = Dim.1, y = Dim.2, color = PlantFamily)) + 
  geom_point (size =3) +
  geom_hline(yintercept = 0, lty = 2, color = "grey", alpha = 0.9) + 
  geom_vline(xintercept = 0, lty = 2, color = "grey", alpha = 0.9) + 
  #stat_ellipse(aes (x= Dim.1, y = Dim.2, color = group))  +   # thisis 95%confidence
  geom_segment(data = PCA_arrows_metrics, aes (x=0, xend= D1end*1, y = 0, yend = D2end*1), 
               arrow = arrow(length = unit(0.3, "picas")), color = "darkblue", inherit.aes = F)  +
  geom_text_repel ( data = PCA_arrows_metrics, aes (x  = D1end*1, y = D2end*1, label = metric), 
                   color = "darkblue", inherit.aes = F , force = 0.6) + 
  geom_text_repel(data = PCA_metric_data, aes (x = Dim.1, y = Dim.2, label = PlantSpeciesfull), fontface = "italic", inherit.aes = F) +
  theme_minimal() + 
  xlab(label = "PC1 (76.5 %)") +
  ylab ("PC2 (14.1 %)") + 
  guides (color= guide_legend( "Plant family")) +
  theme (legend.position = "bottom") +
    scale_color_manual(values=c("Asteraceae"= "#edc948" ,"Cyperaceae" ="#5A6351" ,
                             "Fabaceae" = "#f28e2b" , 
                             "Plantaginaceae"= "#4e79a7","Soil control"= "#9c755f",
                    "Poaceae" = "#7F9A65" )) 



# plotPca  <- fviz_pca_biplot(PCA_all_metrics,axes = c(1,2), 
#                             col.var = "contrib", 
#                             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
#                             repel =T)

plot1 <- fviz_contrib(PCA_all_metrics, choice = "var", axes = 1, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC1")
plot2 <- fviz_contrib(PCA_all_metrics, choice = "var", axes = 2, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC2")
plot3 <- fviz_contrib(PCA_all_metrics, choice = "var", axes = 3, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC3")

ggarrange (plotPca,
           ggarrange (plot1, plot2, plot3, nrow = 3, ncol= 1, labels= c("B", "C", "D")), 
           nrow=1, ncol=2, widths =  c(2, 1), labels= "A") 


```

PCA of treatments along a selection of numeric and phylogenetic alpha and beta-diversities shows a separation into groups along the principal component (PC) axes (Fig. \@ref(fig:plot-PCA-all-metrics)). 
The most notable separation along PC1 divides the treatments into such of low and high alpha-diversities. 
Different placement along PC2 indicate differences in phylogenetic divergence, whereas the within-treatment beta-diversity contributes most to the third dimension (PC3). 
Most of the grasses (Poaceae) are clustered together, being numeric generalists, with the exception of *P. cita* and *L. perenne*. Overall, the forbs are mostly spread along PC2, with *L. autumnalis* and *C. intybus* showing the highest difference to each other, indicating differences in phylogenetic divergence. 


```{r plot-PCA-all-metrics-Poaceae, fig.cap= "Principal component analysis (PCA) of numeric and phylogenetic $\\alpha$ and $\\beta$-diversities per Poacaean plant species. A) and B) PCA-biplots of A) Dimensions 1 and 2, and B) dimensions 2 and 3. Dots are plant species, arrows are metrics of diversity, i.e., properties of the interaction niche. contrib= contribution of variable to placement of treatment in biplot. C)-E) Contributions of metrics to the first three dimensions. PD = Faith's phylogenetic diversity, unique = number of unique ASVs per treatment ($\\gamma$-diversity), $\\beta$~core~ = percentage of AMF species occurring in 60% of replicates per plant species, MPD = mean phylogenetic distance, CU = compositional units (true $\\beta$-diversity), Chao1 = Chao1 diversity, Shannon = Shannon's diversity H', Richness = species richness S.", fig.height=8, fig.width=10}

#Get values for all metrics in one tibble#####
All_metrics_generalists  <-
  adiv_richness %>% 
  left_join(metaM0)  %>%  
  group_by(PlantSpeciesfull)  %>% 
  #mutate (Chao1 = mean (Chao1)) %>% 
  mutate (Shannon = mean (Shannon)) %>%  
  select (sampleID, Shannon) %>% 
  select (!sampleID) %>% 
  unique()  %>%  
  left_join (comp_units %>% select (!repl) %>% select (!"1-CU"))    %>%   #includes CU and unique and richness
  left_join(cores) %>% 
  select (!c(PlantType,uniqueASVsperPlSpe, PlantFamily))  %>% 
   left_join (stand_pd_Glo_all %>% 
               left_join(ses.MPD_Glo, by ="sampleID")  %>%  
               left_join (metaM0)  %>% 
              drop_na ()  %>% 
                group_by (PlantSpeciesfull)  %>%   
               mutate (mean_pd = mean (pd.obs.z), mean_mpd = mean (mpd.obs.z)) %>%  
               select (PlantSpeciesfull,   mean_pd, mean_mpd,PlantFamily)   %>% 
               unique ()  )  %>% 
  filter (PlantFamily == "Poaceae" | PlantFamily == "Plantaginaceae" | PlantFamily == "Soil") %>% 
  dplyr::rename("Richness"= "mean_n_ASV_per_species", "CU" = "CUnits", "β(core)"  = "perc_core",
                 "PD" = "mean_pd", "MPD" = "mean_mpd" )  %>% 
  as.data.frame(row.names = NULL)
rownames(All_metrics_generalists)  <- All_metrics_generalists$PlantSpeciesfull
All_metrics_generalists  <- All_metrics_generalists[,-1]

#PCA
#PCA_all_metrics  <- vegan::rda (All_metrics_generalists, scale = T)
PCA_all_metrics_generalists <- PCA(All_metrics_generalists, quali.sup = 8,   scale.unit = T, graph = F)


#Plot 

PCA_arrows_metrics_gen<-
  PCA_all_metrics_generalists$var$coord %>%  
  as_tibble (rownames = "metric") %>% 
  dplyr::rename("D1end" = "Dim.1", "D2end"= "Dim.2", "D3end"="Dim.3")

PCA_metric_data_gen   <- PCA_all_metrics_generalists$ind$coord  %>%  
  as_tibble(rownames = "PlantSpeciesfull") %>% 
  left_join(metaM0 %>%  select (PlantSpeciesfull, PlantFamily) %>%  unique ())

PCA_eig_m_Dim1_gen <- round (PCA_all_metrics_generalists$eig[1,2],1)
PCA_eig_m_Dim2_gen <- round (PCA_all_metrics_generalists$eig[2,2],1)
PCA_eig_m_Dim3_gen <- round (PCA_all_metrics_generalists$eig[3,2],1)
#Plot 

plotPca_gen1  <- 
  PCA_metric_data_gen %>% 
  mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control")) %>% 
ggplot (aes (x = Dim.1, y = Dim.2, color = PlantFamily)) + 
  geom_point (size =3) +
  geom_hline(yintercept = 0, lty = 2, color = "grey", alpha = 0.9) + 
  geom_vline(xintercept = 0, lty = 2, color = "grey", alpha = 0.9) + 
  #stat_ellipse(aes (x= Dim.1, y = Dim.2, color = group))  +   # thisis 95%confidence
  geom_segment(data = PCA_arrows_metrics_gen, aes (x=0, xend= D1end*1, y = 0, yend = D2end*1), 
               arrow = arrow(length = unit(0.3, "picas")), color = "darkblue", inherit.aes = F)  +
  geom_text_repel ( data = PCA_arrows_metrics_gen, aes (x  = D1end*1, y = D2end*1, label = metric), 
                   color = "darkblue", inherit.aes = F , force = 0.6) + 
  geom_text_repel(data = PCA_metric_data_gen, aes (x = Dim.1, y = Dim.2, label = PlantSpeciesfull), fontface = "italic", inherit.aes = F) +
  theme_minimal() + 
  xlab(label = "PC1 (65.0 %)") +
  ylab ("PC2 (21.1 %)") + 
  guides (color= guide_legend( "Plant family")) +
  theme (legend.position = "bottom") +
    scale_color_manual(values=c(
      "Plantaginaceae"= "#4e79a7","Soil control"= "#9c755f",
                    "Poaceae" = "#7F9A65" )) 

plotPca_gen2  <- 
  PCA_metric_data_gen %>%
  mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control")) %>% 
ggplot (aes (x = Dim.2, y = Dim.3, color = PlantFamily)) + 
  geom_point (size =3) +
  geom_hline(yintercept = 0, lty = 2, color = "grey", alpha = 0.9) + 
  geom_vline(xintercept = 0, lty = 2, color = "grey", alpha = 0.9) + 
  #stat_ellipse(aes (x= Dim.1, y = Dim.2, color = group))  +   # thisis 95%confidence
  geom_segment(data = PCA_arrows_metrics_gen, aes (x=0, xend= D2end*1, y = 0, yend = D3end*1), 
               arrow = arrow(length = unit(0.3, "picas")), color = "darkblue", inherit.aes = F)  +
  geom_text_repel ( data = PCA_arrows_metrics_gen, aes (x  = D2end*1, y = D3end*1, label = metric), 
                   color = "darkblue", inherit.aes = F , force = 0.6) + 
  geom_text_repel(data = PCA_metric_data_gen, aes (x = Dim.2, y = Dim.3, label = PlantSpeciesfull), fontface = "italic", inherit.aes = F) +
  theme_minimal() + 
  xlab(label = "PC1 (21.1 %)") +
  ylab ("PC2 (5.9 %)") + 
  guides (color= guide_legend( "Plant family")) +
  theme (legend.position = "bottom") +
    scale_color_manual(values=c(
      "Plantaginaceae"= "#4e79a7","Soil control"= "#9c755f",
                    "Poaceae" = "#7F9A65" )) 


# plotPca  <- fviz_pca_biplot(PCA_all_metrics,axes = c(1,2), col.var = "contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
#                 repel =T)
# plotPca2  <- fviz_pca_biplot(PCA_all_metrics,axes = c(2,3), col.var = "contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
#                 repel =T)

plot1 <- fviz_contrib(PCA_all_metrics, choice = "var", axes = 1,
                      font.main = c(size =12 ), title= "Contribution of variables to PC1")
plot2 <- fviz_contrib(PCA_all_metrics, choice = "var", axes = 2, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC2")
plot3 <- fviz_contrib(PCA_all_metrics, choice = "var", axes = 3, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC3")

ggarrange (ggarrange (plotPca_gen1,plotPca_gen2, ncol = 2, nrow =1, labels= c("A", "B"), common.legend = T, legend = "bottom"), 
           ggarrange (plot1, plot2, plot3, nrow = 1, ncol= 3,
                      widths = 2, labels= c( "C", "D", "E")), 
           nrow=2, ncol=1, heights= c(2,1) )


```

The examination of the PCA for Poaceae and Plantaginaceae supports the idea that the interaction niche properties differed among these species. Notable plants were *P. cita*, *L. perenne*, *D. glomerata*, *A. capillaris*  and  *P. pratense* with the first four plants showing a tendency to host similar AMF communities among their individuals, i.e., they had core AMF communities which were also of low phylogenetic divergence. Of these four plant species, two hosted AMF species of higher richness than the other two, indicating that numeric richness of the AMF community did not drive differences in beta-diversity and MPD in my dataset. *P. pratense* showed the opposite tendency hosting divergent taxa, i.e., it had an over-dispersed AMF community, and highly dissimilar AMF communities among individuals.



```{r IN-M1-diversity}

## richness, chao, shannon
adiv_richness_M1  <- 
  estimate_richness(ps_M1_roots_Glo_rar, measures = c("Observed", "Shannon")) %>% 
  as_tibble (rownames = "sampleID") %>% 
  left_join (meta_M1 %>%  select (sampleID, PlaSpe, PlantSpeciesfull, PlantFamily), by = "sampleID")  


## richness per species -average
meannumberASVsper_species_M1  <-
  adiv_richness_M1 %>% 
  group_by (PlantSpeciesfull) %>% 
  summarize (meanASV = mean (Observed))


ASV_table_Glo_roots_M1 <- 
  otu_table (ps_M1_roots_Glo_rar) %>%  
  data.frame ()  %>%  t () %>%  
  as_tibble (rownames = "sampleID") 

## unique asvs
unique_M1  <- 
  ASV_table_Glo_roots_M1  %>% 
  pivot_longer(!sampleID, names_to = "ASV_ID", values_to = "ASV_count") %>% 
  filter (ASV_count != 0) %>%  
  left_join(meta_M1 %>%  select (sampleID, PlantSpeciesfull)) %>%  
  group_by (ASV_ID,PlantSpeciesfull ) %>%  
  tally () %>% 
  group_by(PlantSpeciesfull)  %>% 
  tally (name ="uniqueASVsperPlSpe")

## CU ###
comp_units_M1   <- meannumberASVsper_species_M1  %>% 
  left_join(unique_M1, by = "PlantSpeciesfull")  %>% 
  mutate (CUnits = uniqueASVsperPlSpe/(meanASV*5))%>% # repl adjustment nor needed here, because all 5 replicates are available
  mutate ("1-CU" = 1 - CUnits)

### Cores####

ps_test <- ps_M1_roots_Glo_rar  # make a new ps to change its sample_data (core and conglomerte have problems when sample-data can not conglomerated)
sample_data (ps_test)  <- sample_data (ps_M1_roots_Glo_rar) %>% data.frame () %>%  select (PlantSpeciesfull, PlaSpe) %>%  sample_data()
ps_focal_roots_M1_core  <- phylosmith::taxa_core (ps_test, treatment =  "PlantSpeciesfull", frequency =0.6)#see above
ps_focal_roots_M1_core <- conglomerate_samples(ps_focal_roots_M1_core, treatment = "PlantSpeciesfull")

#calculate beta diversity as percentage 
cores_roots_M1  <- 
  as.data.frame (otu_table (ps_focal_roots_M1_core )) %>%   as_tibble(rownames = "ASV_ID") %>% 
  gather (!ASV_ID, key=PlantSpeciesfull, value = ASV_counts)  %>%  
  group_by (PlantSpeciesfull) %>%  
  dplyr::filter (ASV_counts != "0")  %>% 
  dplyr::tally(name="core") %>% 
  left_join(unique_M1, by = "PlantSpeciesfull")  %>% 
  mutate (perc_core = 100* core/uniqueASVsperPlSpe) %>% 
  mutate (perc_core = round (perc_core,1) ) %>% 
  select (PlantSpeciesfull, perc_core) 

### PD####
comm_df_Glo_M1 <- data.frame (t(otu_table (ps_M1_roots_Glo_rar))) # vegan expects samples as rows and ASVs species as columns

#hier total randomised community data frame as null model
stand_pd_Glo_all_M1  <- as_tibble (ses.pd(comm_df_Glo_M1, phy_tree(ps_M1_roots_Glo_rar), include.root = FALSE, null.model = "independentswap", runs=100, iterations=999), rownames="sampleID")

stand_pd_Glo_all_M1  <- 
  stand_pd_Glo_all_M1 %>%  
  left_join (meta_M1 %>% select (sampleID, PlantSpeciesfull)) 

## MPD ###

dist_Glo_M1  <- cophenetic(phy_tree(ps_M1_roots_Glo_rar))
ses.MPD_Glo_M1  <-  as_tibble (ses.mpd (comm_df_Glo_M1, dist_Glo_M1, null.model = "independentswap" ), rownames = "sampleID")

# together PD, MPD
PD_MPD_M1 <-  
  stand_pd_Glo_all_M1 %>%  
  select (sampleID, pd.obs) %>% 
  left_join(ses.MPD_Glo_M1, by = "sampleID") %>%  
  left_join (meta_M1) %>% 
  select (sampleID, pd.obs, mpd.obs, PlaSpe, PlantSpeciesfull) %>% 
  drop_na() %>% 
  group_by (PlantSpeciesfull) %>% 
  mutate (mean_pd = mean (pd.obs), mean_mpd = mean (mpd.obs)) %>%  
  select (PlantSpeciesfull,  mean_pd, mean_mpd)   %>% 
  unique ()  





#Get values for all metrics in one tibble
All_metrics_M1_8Sp  <-
  adiv_richness_M1 %>% 
  group_by(PlantFamily, PlantSpeciesfull)  %>% 
  #mutate (Chao1 = mean (Chao1)) %>% 
  mutate (Shannon = mean (Shannon)) %>%  
  select (sampleID, Shannon) %>% 
  select (!sampleID) %>% 
  unique()  %>%  
  left_join (comp_units_M1 %>%  select (!'1-CU'))    %>%   #includes CU and unique and richness
  left_join(cores_roots_M1) %>% 
  left_join (PD_MPD_M1) %>% 
  dplyr::rename("Richness"= "meanASV", "CU" = "CUnits", "β(core)"  = "perc_core",
                "PD" = "mean_pd", "MPD" = "mean_mpd" , "unique" = "uniqueASVsperPlSpe") %>% 
    add_column (Exp = "E2")



All_metrics_M1  <- 
  All_metrics_M1_8Sp %>% 
  select (!Exp) %>% 
  as.data.frame(row.names = NULL) %>% 
  relocate (where (is.numeric))
rownames(All_metrics_M1)  <- All_metrics_M1$PlantSpeciesfull

##calc of eigenvalues for PC1 for text
PCA_all_metrics_M1 <- PCA(All_metrics_M1, quali.sup = c(9,8),   scale.unit = T, graph = F)


```





```{r euclidean}
# ### Funktion to calculate euclidean distance between tow column a and b
#euclidean <- function(a, b) sqrt(sum((a - b)^2))

# Euclideaen distancs for the focal plants, distance between interaction niche properties ####

## Calculated before

All_metrics_M0_8Sp <-
 All_metrics_M0_8Sp %>%  
  add_column (Exp ="E1") 




### careful to run the properties first as they are named similarly


Ex1_Ex2_distances <- 
  All_metrics_M1_8Sp %>%  
  ungroup() %>% 
  select (!PlantFamily) %>% 
  mutate_at(c(2:8),scale)  %>%    # z score standardisation
  bind_rows(All_metrics_M0_8Sp%>% 
    mutate_at(c(2:8),scale)  %>%  # z score standardisation
  select (!PlantFamily)) %>% 
  group_split (PlantSpeciesfull) %>%  # split into each plant species
  map (~ dist (., method = "euclidean"),.id= PlantSpeciesfull) %>% 
  map (  ~melt (as.matrix(.), varnames =c("A", "B"))) %>%   # put together into tibble again
  map (~filter (., A =="1" & B == "2")) %>%   ## remove unimportant distances
  map_dfr (~select (.,value)) %>%  
  add_column (PlaSpe= c ("AgrCap", "AchMil", "BroWil", 
                           "CicInt", "HolLan",
                           "PoaCit", "PlaLan", "SchAru")) %>% 
  left_join (meta_plants)
#### Hmm, that does not help

```


```{r PCA-M0-M1}


### M0###
## get PCA data 
#--
All_metrics_M0_8Sp_df <-
  All_metrics_M0_8Sp %>% 
data.frame (row.names = "PlantSpeciesfull")



##calc of eigenvalues for PC1 for text
PCA_all_metrics_M0_8Sp <- PCA(All_metrics_M0_8Sp_df, quali.sup = c(9,8),   scale.unit = T, graph = F)

PCA_eig_Dim1 <- round (PCA_all_metrics_M0_8Sp$eig[1,2],1)
PCA_eig_Dim2 <- round (PCA_all_metrics_M0_8Sp$eig[2,2],1)


PCA_arrows_metrics<-
  PCA_all_metrics_M0_8Sp$var$coord %>%  
  as_tibble (rownames = "metric") %>% 
  dplyr::rename("D1end" = "Dim.1", "D2end"= "Dim.2")

PCA_metric_data   <- PCA_all_metrics_M0_8Sp$ind$coord  %>%  as_tibble(rownames = "PlantSpeciesfull") %>% 
  left_join(meta_plants %>%  select (PlantSpeciesfull, PlantFamily) %>%  unique ())

#Plot 

plotPca_M0_8Sp  <- 
  PCA_metric_data %>%  
    ggplot (aes (x = Dim.1, y = Dim.2, color = PlantFamily)) + 
  geom_point (size =3) +
  geom_hline(yintercept = 0, lty = 2, color = "grey", alpha = 0.9) + 
  geom_vline(xintercept = 0, lty = 2, color = "grey", alpha = 0.9) + 
  #stat_ellipse(aes (x= Dim.1, y = Dim.2, color = group))  +   # thisis 95%confidence
  geom_segment(data = PCA_arrows_metrics, aes (x=0, xend= D1end*1, y = 0, yend = D2end*1), 
               arrow = arrow(length = unit(0.3, "picas")), color = "darkblue", inherit.aes = F)  +
  geom_text_repel ( data = PCA_arrows_metrics, aes (x  = D1end*1, y = D2end*1, label = metric), 
                   color = "darkblue", inherit.aes = F , force = 0.6) + 
  geom_text_repel(data = PCA_metric_data, aes (x = Dim.1, y = Dim.2, label = PlantSpeciesfull), fontface = "italic", inherit.aes = F) +
  theme_minimal() + 
  xlab(label = "PC1 (88.0 %)") +
  ylab ("PC2 (6.1 %)") + 
  guides (color= guide_legend( "Plant family")) +
  theme (legend.position = "bottom") +
    scale_color_manual(values=c("Asteraceae"= "#edc948" ,"Cyperaceae" ="#5A6351" ,
                             "Fabaceae" = "#f28e2b" , 
                             "Plantaginaceae"= "#4e79a7","Soil control"= "#9c755f",
                    "Poaceae" = "#7F9A65" )) 



# plotPca  <- fviz_pca_biplot(PCA_all_metrics,axes = c(1,2), 
#                             col.var = "contrib", 
#                             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
#                             repel =T)

plot1 <- fviz_contrib(PCA_all_metrics_M1, choice = "var", axes = 1, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC1")
plot2 <- fviz_contrib(PCA_all_metrics_M1, choice = "var", axes = 2, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC2")
plot3 <- fviz_contrib(PCA_all_metrics_M1, choice = "var", axes = 3, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC3")

ggarrange (plotPca_M0,
           ggarrange (plot1, plot2, plot3, nrow = 3, ncol= 1, labels= c("B", "C", "D")), 
           nrow=1, ncol=2, widths =  c(2, 1), labels= "A") 






#Get values for all metrics in one tibble
All_metrics_M1_8Sp  <-
  adiv_richness_M1 %>% 
  group_by(PlantFamily, PlantSpeciesfull)  %>% 
  #mutate (Chao1 = mean (Chao1)) %>% 
  mutate (Shannon = mean (Shannon)) %>%  
  select (sampleID, Shannon) %>% 
  select (!sampleID) %>% 
  unique()  %>%  
  left_join (comp_units_M1 %>%  select (!'1-CU'))    %>%   #includes CU and unique and richness
  left_join(cores_roots_M1) %>% 
  left_join (PD_MPD_M1) %>% 
  dplyr::rename("Richness"= "meanASV", "CU" = "CUnits", "β(core)"  = "perc_core",
                "PD" = "mean_pd", "MPD" = "mean_mpd" , "unique" = "uniqueASVsperPlSpe")  %>% 
  as.data.frame(row.names = NULL) %>% 
  relocate (where (is.numeric))
rownames(All_metrics_M1_8Sp)  <- All_metrics_M1_8Sp$PlantSpeciesfull

##calc of eigenvalues for PC1 for text
PCA_all_metrics_M1 <- PCA(All_metrics_M1_8Sp, quali.sup = c(9,8),   scale.unit = T, graph = F)

PCA_eig_Dim1 <- round (PCA_all_metrics_M1$eig[1,2],1)

PCA_eig_Dim2 <- round (PCA_all_metrics_M1$eig[2,2],1)


PCA_arrows_metrics<-
  PCA_all_metrics_M1$var$coord %>%  
  as_tibble (rownames = "metric") %>% 
  dplyr::rename("D1end" = "Dim.1", "D2end"= "Dim.2")

PCA_metric_data   <- PCA_all_metrics_M1$ind$coord  %>%  as_tibble(rownames = "PlantSpeciesfull") %>% 
  left_join(meta_plants %>%  select (PlantSpeciesfull, PlantFamily) %>%  unique ())

#Plot 

plotPca_M1  <- 
  PCA_metric_data %>%  
    ggplot (aes (x = Dim.1, y = Dim.2, color = PlantFamily)) + 
  geom_point (size =3) +
  geom_hline(yintercept = 0, lty = 2, color = "grey", alpha = 0.9) + 
  geom_vline(xintercept = 0, lty = 2, color = "grey", alpha = 0.9) + 
  #stat_ellipse(aes (x= Dim.1, y = Dim.2, color = group))  +   # thisis 95%confidence
  geom_segment(data = PCA_arrows_metrics, aes (x=0, xend= D1end*1, y = 0, yend = D2end*1), 
               arrow = arrow(length = unit(0.3, "picas")), color = "darkblue", inherit.aes = F)  +
  geom_text_repel ( data = PCA_arrows_metrics, aes (x  = D1end*1, y = D2end*1, label = metric), 
                   color = "darkblue", inherit.aes = F , force = 0.6) + 
  geom_text_repel(data = PCA_metric_data, aes (x = Dim.1, y = Dim.2, label = PlantSpeciesfull), fontface = "italic", inherit.aes = F) +
  theme_minimal() + 
  xlab(label = "PC1 (76.5 %)") +
  ylab ("PC2 (14.1 %)") + 
  guides (color= guide_legend( "Plant family")) +
  theme (legend.position = "bottom") +
    scale_color_manual(values=c("Asteraceae"= "#edc948" ,"Cyperaceae" ="#5A6351" ,
                             "Fabaceae" = "#f28e2b" , 
                             "Plantaginaceae"= "#4e79a7","Soil control"= "#9c755f",
                    "Poaceae" = "#7F9A65" )) 



# plotPca  <- fviz_pca_biplot(PCA_all_metrics,axes = c(1,2), 
#                             col.var = "contrib", 
#                             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
#                             repel =T)

plot1 <- fviz_contrib(PCA_all_metrics_M1, choice = "var", axes = 1, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC1")
plot2 <- fviz_contrib(PCA_all_metrics_M1, choice = "var", axes = 2, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC2")
plot3 <- fviz_contrib(PCA_all_metrics_M1, choice = "var", axes = 3, 
                      font.main = c(size =12 ), title= "Contribution of variables to PC3")

ggarrange (plotPca_M1,
           ggarrange (plot1, plot2, plot3, nrow = 3, ncol= 1, labels= c("B", "C", "D")), 
           nrow=1, ncol=2, widths =  c(2, 1), labels= "A") 


```
### Hyp 4 DAA 


```{r plot-DAA-soil, include = T, fig.cap = "Alteration of the soil AMF community by eight different plant species. The plot panels show the results from the differential abundance analysis (DAA) between soils associated with eight different plant species and control soil. Each point represents one ASV, with the color indicating the AMF order, and the size the mean relative abundance of the ASV in regards to all AMF ASVs of the respective plant. The AMF taxa are organised by the phylogenetic tree of the identified AMF genera (left). The log2-fold change between the soils describes the log-ratio of the respective ASV between the two soils. Significant log2-fold changes are indicated by non-transparent coloring (p-value < 0.05).", fig.height= 8, fig.width=13}


### Add a new meta column to the data
# combination of PlaSpe and root/soil, e.g. AchMil-soil, AchMil-roots
# for use as grouping factor in edgeR!
ps_edgeR <- ps_M1_allASVs

new_sampledata <- 
  sample_data (ps_edgeR) %>% 
  data.frame () %>% 
  unite (col =PlaSpe_RS, c(PlaSpe, roots_soil), sep= "_" ) %>% 
  sample_data()
sample_data(ps_edgeR)  <- new_sampledata


# at genus level - needed for Tree building and taxon names
ps_edgeR_genus <- tax_glom(ps_edgeR, taxrank = "Genus", NArm = F)

#Object for edgeR ##
# rows OTUs, columns = samples
# get the count table as  df
df <- otu_table(ps_edgeR) %>%  
  data.frame ()

#Get taxon table for the ASVs - needed as meta table for the DAA results
taxa_edgeR <- 
  tax_table (ps_edgeR) %>% 
  data.frame () %>%  
  mutate(GenusLabel = ifelse(!is.na(Genus), paste(Genus), 
                             ifelse(!is.na(Family), paste('Unid. ', Family, sep = ""), 
                                    ifelse(!is.na(Order), paste('Unid. ', Order, sep = ""),
                                           ifelse(!is.na(Class), paste('Unid. ', Class, sep = ""), paste("Unid. ", Phylum, sep = "")))))) %>% 
  as_tibble (rownames = "ASV_ID" ) %>%  
  select (ASV_ID, GenusLabel,Phylum, Class, Family, Genus)

## Grouping : PlaSpe in roots and PlaSpe in soil = 16 treatments
group = factor (sample_data (ps_edgeR)$PlaSpe_RS)

## prepare edgeR object y
y <- DGEList(counts = df, group = group)
DAA_dim_before_filter <- dim(y)
# Filtering ####
#filter small OTUs- that removes about 2000 OTUs
keep <- filterByExpr(y)
# filter the dataset for the ASVs to keep
y <- y[keep, , keep.lib.sizes=FALSE]
DAA_dim_after_filter <-  dim (y)

#Normalisation####
#The calcNormFactors function normalises the library sizes by finding a set of scaling factors
#for the library sizes that minimizes the log-fold changes between the samples for most genes.
y<- calcNormFactors(y)
#y$samples
#A normalization factor below one indicates that a small number of high count genes
#are monopolizing the sequencing, causing the counts for other genes to be lower than would
#be usual given the library size.
y$samples$group  <- relevel (y$samples$group, ref = "SoiCon_soil")

design <- model.matrix (~ group , data = y$samples)

#Dispersions - GLM####
#For general experiments (with multiple factors), edgeR uses the Cox-Reid profile-adjusted
#likelihood (CR) method in estimating dispersions [25].
y <- estimateDisp(y, design)

#add sample information
y$samples$PlaSpe <- factor (sample_data (ps_edgeR)$PlaSpe)
y$samples$PlantSpeciesfull <- factor (sample_data (ps_edgeR)$PlantSpeciesfull)
y$samples$PlantFamily <- factor (sample_data (ps_edgeR)$PlantFamily)


# relevel reference level

# DESIGN: Decide on grouping ####
# see Law 2020, A guide to creating design matrices ...
## Model design 

colnames(design) <- levels(y$samples$group)
#check the names of the columns with 
# colnames(design)
# to get the needed comparisons (either by writing contrasts or by direct use of the coefficient's results)

# testing for differentially abundant (DA) OTUs
#While the likelihood ratio test is a more obvious choice for inferences with GLMs, the QL
#F-test is preferred as it reflects the uncertainty in estimating the dispersion for each gene. It
#provides more robust and reliable error rate control when the number of replicates is small.
#The QL dispersion estimation and hypothesis testing can be done by using the functions
#glmQLFit() and glmQLFTest().


#GLM ####
fit <- glmQLFit(y, design)

#GLM F-test #####
#compare the coefficients of the glm 
# i.e. compare treatments
AchMil_soil <- glmQLFTest(fit, coef=3) 
#Soil PlaSpe results####
# Ach Mil data soil ##
DAA_AchMil_soil <-
  AchMil_soil$table %>%  
  as_tibble (rownames = "ASV_ID") %>% 
  left_join (taxa_edgeR) %>% 
  filter (Phylum == "Glomeromycota" ) %>% 
  add_column (PlaSpe = "AchMil", roots_soil = "soil") %>% ### change here 
  mutate (Sign = case_when(PValue<=0.05 ~ "sign.", PValue > 0.05 ~ "ns")) 

# Agr Cap soil ##
# i.e. compare treatments
AgrCap_soil <- glmQLFTest(fit, coef=5) 

# Ach Mil data soil
DAA_AgrCap_soil <-
  AgrCap_soil$table %>%  
  as_tibble (rownames = "ASV_ID") %>% 
  left_join (taxa_edgeR) %>% 
  filter (Phylum == "Glomeromycota" ) %>% 
  add_column (PlaSpe = "AgrCap", roots_soil = "soil") %>% ### change here 
  mutate (Sign = case_when(PValue<=0.05 ~ "sign.", PValue > 0.05 ~ "ns")) 

## BroWIl soil
BroWil_soil <- glmQLFTest(fit, coef=7) 

DAA_BroWil_soil <-
  BroWil_soil$table %>%  
  as_tibble (rownames = "ASV_ID") %>% 
  left_join (taxa_edgeR) %>% 
  filter (Phylum == "Glomeromycota" ) %>% 
  add_column (PlaSpe = "BroWil", roots_soil = "soil") %>% ### change here 
  mutate (Sign = case_when(PValue<=0.05 ~ "sign.", PValue > 0.05 ~ "ns"))

# CicInt data soil


CicInt_soil <- glmQLFTest(fit, coef=9) 

DAA_CicInt_soil <-
  CicInt_soil$table %>%  
  as_tibble (rownames = "ASV_ID") %>% 
  left_join (taxa_edgeR) %>% 
  filter (Phylum == "Glomeromycota" ) %>% 
  add_column (PlaSpe = "CicInt", roots_soil = "soil") %>% ### change here 
  mutate (Sign = case_when(PValue<=0.05 ~ "sign.", PValue > 0.05 ~ "ns")) 

# HolLan data soil


HolLan_soil <- glmQLFTest(fit, coef=11) 

DAA_HolLan_soil <-
  HolLan_soil$table %>%  
  as_tibble (rownames = "ASV_ID") %>% 
  left_join (taxa_edgeR) %>% 
  filter (Phylum == "Glomeromycota" ) %>% 
  add_column (PlaSpe = "HolLan", roots_soil = "soil") %>% ### change here 
  mutate (Sign = case_when(PValue<=0.05 ~ "sign.", PValue > 0.05 ~ "ns")) 

# PlaLan data soil

PlaLan_soil <- glmQLFTest(fit, coef=13) 

DAA_PlaLan_soil <-
  PlaLan_soil$table %>%  
  as_tibble (rownames = "ASV_ID") %>% 
  left_join (taxa_edgeR) %>% 
  filter (Phylum == "Glomeromycota" ) %>% 
  add_column (PlaSpe = "PlaLan", roots_soil = "soil") %>% ### change here 
  mutate (Sign = case_when(PValue<=0.05 ~ "sign.", PValue > 0.05 ~ "ns")) 

# PoaCit data soil


PoaCit_soil <- glmQLFTest(fit, coef=15) 

DAA_PoaCit_soil <-
  PoaCit_soil$table %>%  
  as_tibble (rownames = "ASV_ID") %>% 
  left_join (taxa_edgeR) %>% 
  filter (Phylum == "Glomeromycota" ) %>% 
  add_column (PlaSpe = "PoaCit", roots_soil = "soil") %>% ### change here 
  mutate (Sign = case_when(PValue<=0.05 ~ "sign.", PValue > 0.05 ~ "ns")) 


# SchAru data soil

SchAru_soil <- glmQLFTest(fit, coef=17) 

DAA_SchAru_soil <-
  SchAru_soil$table %>%  
  as_tibble (rownames = "ASV_ID") %>% 
  left_join (taxa_edgeR) %>% 
  filter (Phylum == "Glomeromycota" ) %>% 
  add_column (PlaSpe = "SchAru", roots_soil = "soil") %>% ### change here 
  mutate (Sign = case_when(PValue<=0.05 ~ "sign.", PValue > 0.05 ~ "ns")) 

## Subset the genus level data  for Glo
ps_edgeR_glo_genus <- subset_taxa(ps_edgeR_genus, Phylum == "Glomeromycota")
ps_edgeR_glo_genus <- prune_taxa (taxa_sums(ps_edgeR_glo_genus)>=1, ps_edgeR_glo_genus)

# get the tree data
MyTree <-    ps_edgeR_glo_genus %>% phy_tree

# Save names of taxa in tree
TreeTax <-  taxa_names(ps_edgeR_glo_genus)

# create new taxonomy labels
df.tax <-  ps_edgeR_glo_genus %>% tax_table %>% as.data.frame
df.tax$ASV_ID   <-  df.tax %>% row.names # add column with the ASV iD 

df.tax <-  df.tax  %>% mutate( TaxLabel = paste(Family, Genus, sep = "_")) %>%
            select(ASV_ID, TaxLabel, Phylum, Class, Order, Family, Genus)

# Change the NA in the taxon table to the nearest identified taxon
df.tax = df.tax %>%
  mutate(GenusLabel = ifelse(!is.na(Genus), paste(Genus), 
                             ifelse(!is.na(Family), paste('Unid. ', Family, sep = ""), 
                                    ifelse(!is.na(Order), paste('Unid. ', Order, sep = ""),
                                          ifelse(!is.na(Class), paste('Unid. ', Class, sep = ""), paste("Unid. ", Phylum, sep = "")))))) 

# get a tibble of the whole taxa table incl new GenusLabel
taxa_names <- df.tax %>% as_tibble ()


# Tree plot ####
test_tree <- rotateConstr(MyTree, constraint = c("ASV_3904" ,"ASV_1540", "ASV_1320",   "ASV_1856", 
                                                 "ASV_2852","ASV_1705","ASV_1334", "ASV_550" ,
                                                 "ASV_270","ASV_386",  "ASV_662" , "ASV_988" , 
                                                 "ASV_247" , "ASV_713"  , "ASV_357", "ASV_253" ,  "ASV_14" ,   "ASV_3003"))

p  = ggtree(test_tree, ladderize = F) %<+% df.tax

p_tree <- 
  p +  geom_tiplab(aes(label = GenusLabel, color = Order), align = TRUE, size = 4) +
 # geom_tippoint(aes(color= Order), size=3, show.legend = F) +
  theme_tree2() +
  theme (plot.margin = unit (c(8,5,6.5,5), "mm")) + 
  xlim(NA, 0.7) +
  theme (legend.position = "none")

#  get the order of the tree tips for use in the DAA plot
order_taxa <- get_taxa_name(p) %>%  
  as_tibble () %>% 
  dplyr::rename ("ASV_ID" = "value") %>%  
  left_join (taxa_names) %>% 
  add_column (order = c(1:18))

# get relative abundances for the ASVs for later use in the DAA plot
ps_edgeR_glo_ASV <- subset_taxa(ps_edgeR, Phylum == "Glomeromycota")
ps_edgeR_glo_ASV_rel <- relative_abundance(ps_edgeR_glo_ASV)

rel_ASV_abundance_soil <- 
  data.frame (otu_table(ps_edgeR_glo_ASV_rel))  %>%  
  as_tibble(rownames ="ASV_ID") %>%
  pivot_longer(!ASV_ID, names_to = "sampleID", values_to = "rel_ASV_per_sample") %>% 
  left_join((tax_table(ps_edgeR_glo_ASV_rel) %>% data.frame () %>% as_tibble (rownames = "ASV_ID")), by= "ASV_ID")  %>% 
  #filter (rel_ASV_per_sample!=0)  %>% 
  left_join (meta_M1Wcontrol) %>% ## these are the relative abundances per sample
  group_by(roots_soil,PlaSpe, ASV_ID) %>%  # group to seperate soil from roots for each  PlaSpe , to get rel abu of ASVs per PlaSpe
  summarise (mean_rel_ASV_per_PlaSpe =mean(rel_ASV_per_sample)) %>% 
  filter (roots_soil =="soil") # for Soil data only


#DAA ALL ####
#get data  for all DAA results into one tibble
# add information on relative abundance of the ASVs per Glo community!
# add genus label
DAA <- bind_rows(DAA_AchMil_soil, DAA_AgrCap_soil, DAA_BroWil_soil, DAA_CicInt_soil, 
                 DAA_HolLan_soil, DAA_PlaLan_soil, DAA_PoaCit_soil,  DAA_SchAru_soil) %>%  
  left_join (order_taxa %>% select (Order, GenusLabel, order), by = "GenusLabel") %>% 
  left_join (rel_ASV_abundance_soil)  %>% 
  filter (!is.na (mean_rel_ASV_per_PlaSpe))  # remove all rel abundances and logFC that have 0 abundance in the respective PlaSpe

## make a dummy df to add a blank geom to the DAA plot (without it, some of the 
# AMF genera are mssing in the DAA plot
# and it cannot be aligned with tree)
DAA_empty_fields <- order_taxa %>%  add_column(logFC = 0, Sign = "ns", mean_rel_ASV_per_PlaSpe = 0) 




# Plot DAA ####
plotDAA <-
DAA %>%   mutate (across (PlaSpe, factor, levels = c("AchMil", "CicInt", "PlaLan","PoaCit", "SchAru", "BroWil", "AgrCap", "HolLan" ))) %>% 
  ggplot (aes (x= logFC,  y= reorder (GenusLabel, -order), color =Order, alpha = Sign, size = mean_rel_ASV_per_PlaSpe)) + 
  geom_blank (data =DAA_empty_fields, mapping = aes (x= logFC, y = reorder (GenusLabel, -order), size =mean_rel_ASV_per_PlaSpe)) +  ##this adds blank data - to include All AMF that are in the tree!!
  geom_jitter(width =0.4) +  # geom_jitter
  facet_wrap(~PlaSpe, nrow =1) +
  theme_classic() + 
  theme (axis.title.y = element_blank(),
         axis.ticks.y = element_blank(), 
         axis.line.y = element_blank(),
         axis.text.y = element_blank()) +
  geom_vline(xintercept = 0, linetype = "dashed", color ="darkgrey") + 
  scale_alpha_discrete(range = c(0.3, 1)) +
  theme (legend.position = "right" ) +
  xlim(-9,13) +
  labs (size = "Mean relative abundance of ASV ", color = "AMF order", alpha = "Significance")


# Plot tree and DAA together #####
ggarrange (p_tree, plotDAA, nrow = 1, widths = c(0.4,1))
```



## Hyp 5


```{r plot}
 
### needs still data from Ch3 markdown code
NL_all  %>%  
    #group_by (type,PlantSpeciesfull) %>%  
  filter (type =="soil") %>% 
  group_by (PlantSpeciesfull) %>%  
  summarize (mean_AMF = mean (AMF), SD =sd(AMF)) %>% 
    left_join (meta_plants) %>% 
  left_join (PC_data_M1roots) %>% 
    ggplot( aes(x=reorder (PlantSpeciesfull, M1_M2_order), y=mean_AMF, fill=PlantFamily)) + # reorder to get plants in preferred order
  #facet_grid( scales = "free", rows = vars (type)) + 
    geom_col (stat = "identity", colour = "black") +
    geom_errorbar(aes (ymin = mean_AMF, ymax =mean_AMF+SD)) + 
    xlab("Plant species") +
    ylab(expression("NL 16:1"*omega*"5 in nmol/g substrate"))+
    theme_light () +
    theme (axis.text.x=element_text(family= "sans", size = 9, angle=45, hjust =1, color = "black" ))  +
    theme (axis.text.y=element_text(family= "sans", size = 9, color = "black"))  +
    theme (axis.title = element_text(family = "sans", size = 11 ),   
           legend.title=element_text(size=12),
           legend.text=element_text(size=11)
           ) + 
    theme (strip.text = element_text (family = "sans", size = 11, color = "black"))  +
    scale_fill_manual(values=c("Asteraceae"= "#edc948" ,
                               "Plantaginaceae"= "#4e79a7",
                               "Poaceae" = "#7F9A65" ), name = "Plant family") +
  ggsignif::geom_signif (      comparisons = df$groups,
    annotation = c (df %>% pull (p.adj.signif)),
    step_increase = 0.06, vjust = 0.5) +
   theme (legend.position = "none")

```


\newpage

# Discussion


\newpage

# Supplementary material
## Supplementary methods

### Sample preparation and DNA extraction

After harvest, the root system of each individual plant was thoroughly washed in distilled water to remove soil. Roots were cut with a scalpel into small segments of approximately 0.5 to 1 cm length to subsample randomly for DNA extraction.
About 50 mg of pooled root segments were weighed into a 1.5 mL Eppendorf tube containing steel beads (Green Eppendorf Lysis Kit, Next Advance, Inc., USA) and homogenised for 2 x 30 s at 8,000 rpm (~ 6,000 X g) (Precellys Evolution, Bertin instruments, FR). 
CTAB extraction buffer (600 µL, 2 % hexadecyl(trimethyl)ammonium bromide, 1 % polyvinylpyrrolidone (PVP40), 100 mM Tris(hydroxymethyl)aminomethane hydrochloride (tris-HCl), 1.4 M NaCl, 20 mM Ethylenediaminetetraacetic acid (EDTA)) was added and the tube incubated at 60 °C for 1 hr [@Doyle1991a]. The tube was shaken carefully every 20 min to ensure uniform treatment of the root homogenate. After incubation, 600 µL chloroform were added and the mixture was centrifuged at 10,000 rpm (~ 9,200 X g) for 2 s (Eppendorf centrifuge 5415R, Germany) and the aqueous layer transferred to a new 1.5 mL tube using a wide bore pipette tip.
The sample was gently mixed with 800 µL cold isopropanol and put on ice for 10 min to precipitate the DNA. By centrifugation at 10,000 rpm for 60 s the DNA was pelleted, and the supernatant could be carefully discarded. The DNA pellet was washed twice with 800 µL of 80 % ethanol by gently mixing, followed by centrifugation at 10,000 rpm (~ 9,200 X g) for 1 min.
The supernatant was discarded and the pellet air-dried upside down at room temperature. The DNA pellet was resuspended in 40 µL TE buffer (10 nM Tris-HCl, 1mM EDTA, adjusted to pH = 7.4) and the quality and concentration of the DNA extracts assessed by spectrophotometry (Nanodrop NP80, Implen, Germany) before the DNA extract was frozen at -80 °C until further processing.

### PCR and sequencing 
To identify the AMF community the internal transcribed spacer 2 (ITS2) region of the eukaryotic ribosomal DNA was amplified by polymerase chain reaction (PCR) with the modified versions of the primers ITS3 (5'-**CAHCGATGAAGAACGYRG-3'**) and ITS4 (5'-**TCCTSCGCTTATTGATATGC**-3') [@Tedersoo2014]. 
The 50 µL PCR reaction mix contained the extracted DNA at a concentration of 2 ng µL^-1^, 25 µL of 2 x MyTaq^TM^ Red Mix (Bioline, London, UK), 1 µL of each 10 µM primer and 8 µL 5 x TBT-Par as amplification enhancer [@Samarakoon2013]. 
Thermal cycling conditions were as follows: 5 min at 95 °C, then 35 cycles at 95 °C for 45 s, 50 °C for 45 s, and 70 °C for 60 s; followed by 15 min at 72 °C (GeneAmp PCR System 2700, Applied Biosciences, USA). 
The PCR product was cleaned with ExoSAP-IT^TM^ (Thermo Fisher Scientific, USA) before it was sent to sequencing on an Illumina MiSeq (AGRF, Melbourne, Australia) to generate paired-end reads of 300 bp. 
The image analysis for the generated data was performed in real time by the MiSeq Control Software (MCS) 2.6.2.1 and Real Time Analysis (RTA) 1.18.54. 
The Illumina bcl2fastq 2.20.0.422 pipeline was used to infer the sequence data.

### Processing of raw sequence reads

Paired-end reads were trimmed using *cutadapt* 3.2 (minimum primer overlap = 6; maximal error rate = 0.12) to remove the primer sequences and quality checked, merged and filtered using the DADA2 ITS pipeline 1.18 (https://benjjneb.github.io/dada2/ITS_workflow.html) in R 4.0.4 [@R2021]. 
Filtering was applied using the default parameters except for the maximum allowance of errors for the reverse reads which were set at 4 (allowed error for forward reads = 2) due to their lower quality. Adjusting the error allowance allows for appropriate filtering of paired-end reads, because the truncation of reads to remove low quality regions is unsuitable for ITS sequences as they have variable lengths [@Tedersoo2015]. 
Pseudo-pooling of the samples was included in the DADA2 method to reduce the loss of sequence variants that might be rare in some samples but not in others. 
Inferring ASVs in pseudo-pooling mode includes an additional step in which each sample is compared against the whole set of ASVs of the data to identify rare reads. 
Next, chimeric reads were discarded using default parameters and the fungal ITS classifiers naïve Bayes trained on the dynamic UNITE 8.2 (2020) reference database to assign the fungal taxonomy [@Nilsson2018a]. 
To examine if the detected pool of fungal ASVs represents the total possible pool for each treatment, inter- and extrapolated rarefaction and sampling completeness curves were calculated in R package *iNEXT* `r packageVersion ("iNEXT")` [@Hsieh2016; @Chao2014]. 
The extrapolation was based on estimated richnesses [@Colwell2012] and included confidence intervals based on the bootstrap method [@Chao2012]. 
Additionally, for each treatment a sampling coverage curve was constructed, i.e., showing the proportion of the total sequence reads  that belong to the AMF species identified in the treatment. 
The samples were then re-sampled to the smallest common sample coverage (coverage-based rarefaction). All sampling curves were calculated in R package *iNEXT* [@Hsieh2016; @Chao2014], and the standardisation to equal coverage was computed using the function "phyloseq_coverage_raref" with 99 iterations in the package *metagMisc* `r packageVersion ("metagMisc")` (https://github.com/vmikk/metagMisc/) on the Rāpoi High Performance Compute Cluster (Victoria University of Wellington, NZ).
The data was then filtered to contain only sequences assigned to the subphylum Glomeromycotina, which are considered to be AMF. 
Fungal metabarcoding often results in many sequences that cannot be identified  at a meaningful taxonomic level [@Nilsson2016], I therefore used a phylogenetic approach, analysing all ASVs that were identified as subphylum Glomeromycotina as a proxy for an AMF species. 




### NMDS
To compute ...
First, a NMDS scree plot that shows the final stress *versus* the number of dimensions (k) was computed. For the NMDS, the number of dimensions was chosen after which additional axes would not provide much additional reduction in stress. 
Next, the resulting stress of the NMDS at the chosen dimension was compared to the stress values obtained by computing NMDS on randomised data (1000 permutations with preserved AMF richness per sample). The solution obtained by NMDS was only selected when it was significantly better than the solutions from randomised data. 

## Supplementary results

### Rarefaction and sample coverage curves

```{r plot-rarefaction-ALL, fig.cap = "A) Rarefaction (solid line segments) and extrapolation (dotted line segments) sampling curves of fungal ASV richness for each plant species and soil. B) Sample completeness curves by sequence reads. c) Sample coverage curves. Shaded areas in each plot show the 95% confidence interval of the extrapolation. ", fig.height=8, fig.width=12, dpi = 300 }
#agglomerate to Plant Species
ps_ALL_perPlaSpe  <- merge_samples(ps_ALL_0, group = "PlantSpeciesfull")

#make df for Glo_PlaSpe data (empty samples samples pruned )
comm_df_ALL_PlaSpe  <- data.frame (otu_table (ps_ALL_perPlaSpe)) 

#rarefaction in iNEXT 
iNext_ALL_PlaSpe_richness <- iNEXT (t (comm_df_ALL_PlaSpe), 
                                q= 0, # richness
                                datatype =  "abundance", 
                                endpoint = NULL, 
                                knots = 400 )
# plot 
p1 <- ggiNEXT(iNext_ALL_PlaSpe_richness, type = 1) +
  theme_classic() + 
  scale_shape_manual(values = c(0,1, 2,3,4,5,6,7, 8,9,10, 12, 13,14,15, 16,17,22, 23,24, 25)) + 
  scale_y_continuous (name = "ASV richness") +
  scale_x_continuous(name = "Number of sequence reads")+
  theme (axis.text = element_text(size =14), 
         axis.title = element_text(size =18),
         legend.text = element_text(face = "italic"))+
 guides(     colour=guide_legend(title="Plant species"), 
             fill=guide_legend(title="Plant species"), 
             shape=guide_legend(title="Plant species"))


p2 <- ggiNEXT(iNext_ALL_PlaSpe_richness, type = 2) +
  theme_classic() + 
  scale_shape_manual(values = c(0,1, 2,3,4,5,6,7, 8,9,10, 12, 13,14,15, 16,17,22, 23,24, 25)) + 
  scale_x_continuous(name = "Number of sequence reads")+
  theme (axis.text = element_text(size =14), 
         axis.title = element_text(size =18), 
         legend.text = element_text(face = "italic"))+
 guides(     colour=guide_legend(title="Plant species"), 
             fill=guide_legend(title="Plant species"), 
             shape=guide_legend(title="Plant species"))

p3 <- ggiNEXT(iNext_ALL_PlaSpe_richness, type = 3) +
  theme_classic() + 
  scale_shape_manual(values = c(0,1, 2,3,4,5,6,7, 8,9,10, 12, 13,14,15, 16,17,22, 23,24, 25)) + 
  scale_y_continuous(name = "ASV richness")+
  scale_x_continuous (labels = scales::percent) + 
  theme (axis.text = element_text(size =14), 
         axis.title = element_text(size =18),  
         legend.text = element_text(face = "italic"))+
 guides(     colour=guide_legend(title="Plant species"), 
             fill=guide_legend(title="Plant species"), 
             shape=guide_legend(title="Plant species"))

ggarrange (p1,p2,p3, ncol = 3, common.legend = T, labels = "AUTO", legend = "bottom")


```


```{r plot-rarefaction-AMF, include =F,  fig.cap= "Rarefaction (solid line segments) and extrapolation (dotted line segments) sampling curves of AMF ASV richness for each plant species and soil. Shaded areas show the 95% confidence interval of the extrapolation. A) Rarefaction and extrapolation based on sequencing reads. B) Coverage-based rarefaction and extrapolation sampling curves.", fig.height=8, fig.width=10, dpi = 300}

# 
# #agglomerate to Plant Species
# ps_Glo_perPlaSpe  <- merge_samples(ps_Glo, group = "PlantSpeciesfull")
# 
# #make df for Glo_PlaSpe data (empty samples samples pruned )
# comm_df_Glo_PlaSpe  <- data.frame (otu_table (ps_Glo_perPlaSpe)) # vegan expects samples as rows and 
# 
# #ASVs species as columns
# 
# #rarefaction instead 
# iNext_PlaSpe_richness <- iNEXT (t (comm_df_Glo_PlaSpe), 
#                        q= 0, # richness
#                        datatype =  "abundance", 
#                        endpoint = NULL, 
#                        knots = 400 )
# # plot 
# p1 <- ggiNEXT(iNext_PlaSpe_richness, type = 1) +
#   theme_classic() + 
#   scale_shape_manual(values = c(0,1, 2,3,4,5,6,7, 8,9,10, 12, 13,14,15, 16,17,22, 23,24, 25)) + 
#   scale_y_continuous (name = "ASV richness") +
#   scale_x_continuous(name = "Number of sequence reads", limits = c(-100, 30010)) +
#   theme (axis.text = element_text(size =16), 
#          axis.title = element_text(size =20),  
#          legend.text = element_text (face = "italic"))
# 
# 
# p2 <- ggiNEXT(iNext_PlaSpe_richness, type = 3) +
#   theme_classic() + 
#   scale_shape_manual(values = c(0,1, 2,3,4,5,6,7, 8,9,10, 12, 13,14,15, 16,17,22, 23,24, 25)) + 
#   scale_y_continuous (name = "ASV richness") +
#   theme (axis.text = element_text(size =16), 
#          axis.title = element_text(size =20),     
#          legend.text = element_text (face = "italic"))
# 
# 
# ggarrange (p1,p2, common.legend = T, labels = "AUTO", legend = "bottom")

```


### All metrics results

```{r pd-table1, tab.cap = "Faith's phylogenetic diversity. Results for all replicates. Results significantly different from the null community are in bold.", label = "pd-table1" , tab.id = "pd-table1" }
stand_pd_Glo_all %>%  
  left_join(metaM0) %>%  
  select (!c(sortedPlantSpecies, PlaSpe, runs, filename, pd.obs.rank)) %>%  
  mutate(round (across (3:6),2)) %>% 
  mutate(pd.obs.p =round (pd.obs.p,4)) %>%  
  flextable ()  %>% 
  set_header_labels(sampleID = "sample ID", ntaxa ="n (AMF)", pd.obs = "PD", pd.rand.mean = "mean PD in null community", 
                    pd.rand.sd = "SD of PD in null community", pd.obs.z = "Standardised effect size of PD vs. null communities",
                    pd.obs.p =" p-value of observed PD vs. null communities" , PlantFamily = "Plant family", 
                    PlantSpeciesfull = "Plant species", PlantType = "Plant functional role") %>% 
  bold (i= ~pd.obs.p < 0.05 ) %>%  
    italic (j = "PlantSpeciesfull", part = "body")  %>% 
  bold (i= ~pd.obs.p > 0.95 ) 
```

```{r pd-table2, tab.cap = "Faith's phylogenetic diversity. Results for merged samples per plant species. Results significantly different from the null community are in bold.", label = "pd-table2" , tab.id = "pd-table2" }
stand_pd_Glo_PlaSpe %>%  
  select (!c( runs, pd.obs.rank)) %>%  
  mutate(round (across (3:6),2)) %>% 
  mutate(pd.obs.p =round (pd.obs.p,4)) %>%  
  flextable ()  %>% 
  set_header_labels(sampleID = "Plant species", ntaxa ="n (AMF)", pd.obs = "PD", pd.rand.mean = "mean PD in null community", 
                    pd.rand.sd = "SD of PD in null community", pd.obs.z = "Standardised effect size of PD vs. null communities",
                    pd.obs.p =" p-value of observed PD vs. null communities" ) %>% 
  bold (i= ~pd.obs.p < 0.05 ) %>%  
    italic (j = "sampleID", part = "body")  %>% 
  bold (i= ~pd.obs.p > 0.95 ) 
```

```{r mpd-table1, tab.cap = "Mean phylogenetic distance (MPD). Results for all replicates. Results significantly different from the null community are in bold.", label = "mpd-table1" , tab.id = "mpd-table1" }
ses.MPD_Glo %>%  
  left_join(metaM0) %>%  
  select (!c(sortedPlantSpecies, PlaSpe, runs, filename, mpd.obs.rank)) %>%  
  mutate(round (across (3:6),2)) %>% 
  mutate(mpd.obs.p =round (mpd.obs.p,4)) %>%  
  flextable ()  %>% 
  set_header_labels(sampleID = "sample ID", ntaxa ="n (AMF)", mpd.obs = "MPD", mpd.rand.mean = "mean MPD in null community", 
                    mpd.rand.sd = "SD of MPD in null community", mpd.obs.z = "Standardised effect size of MPD vs. null communities",
                    mpd.obs.p =" p-value of observed MPD vs. null communities" , PlantFamily = "Plant family", 
                    PlantSpeciesfull = "Plant species", PlantType = "Plant functional role") %>% 
  bold (i= ~mpd.obs.p < 0.05 ) %>%  
  italic (j = "PlantSpeciesfull", part = "body")  %>% 
  bold (i= ~mpd.obs.p > 0.95 ) 
```




```{r mpd-table2, tab.cap = "Mean phylogenetic distance (MPD). Results for merged samples per plant species. Results significantly different from the null community are in bold.", label = "mpd-table2" , tab.id = "mpd-table2"}
ses.MPD_Glo_PlaSpe %>%  
  select (!c( runs, mpd.obs.rank)) %>%  
  mutate(round (across (3:6),2)) %>% 
  mutate(mpd.obs.p =round (mpd.obs.p,4)) %>%  
  flextable ()  %>% 
  set_header_labels(sampleID = "Plant species", ntaxa ="n (AMF)", mpd.obs = "MPD", mpd.rand.mean = "mean MPD in null community", 
                    mpd.rand.sd = "SD of MPD in null community", mpd.obs.z = "Standardised effect size of MPD vs. null communities",
                    mpd.obs.p =" p-value of observed MPD vs. null communities" ) %>% 
  bold (i= ~mpd.obs.p < 0.05 ) %>%  
    italic (j = "sampleID", part = "body")  %>% 
  bold (i= ~mpd.obs.p > 0.95 ) 
```




```{r plot-treemap, include = F,  fig.cap ="Distribution of ASVs across Glomeromycotinian genera and families and absolute links per AMF ASVs. Each box symbolises one AMF species and the size of the boxes is proportional to the number of root samples this AMF species occurred in, i.e., it is a proxy for the links per AMF ASV. Values reach from 1 (smallest box) to 59 (largest box) links per AMF species. Diversisporaceae are not labelled, with 2 ASV unidentified at genus level. AMF ASVs with a large number of links are interaction generalists. The absolute number of the ASVs per family of the Glomeromycotinia differs considerably. Each AMF family consists of a spectrum of generalist and specialist species, with the Gigasporaceae as notable exception containing in comparison a higher proportion of generalist AMF species than for example the Archaeosporaceae.", fig.height= 6, fig.width= 8}
#Which AMF taxa act as numeric generalists or specialists are illustrated in Fig. \@ref(fig:plot-treemap) and in Table \@ref(tab:AMFgeneralists). As already described above, tWhile the Archaeosporaceae comprise of the highest number of ASVs, other families, like the Gigasporaceae show a wide distribution in the root samples for a high proportion of their ASVs, i.e., more links per AMF ASV. Overall, all AMF families except Diversisporaceae are widely distributed in the 20 treatments.

# Plot Treemap ASVs Verteilung####
  
# das zeigt im prinzip welche ASVs genealisten 
#(große Kästchen und specialisten (kleine Kästchen sind) )
#Species degree in a treemap, bezogen aud die AMF genera
library(treemapify)
p   <-   ASV_table_Glo  %>%  
  select(-c(Kingdom, Phylum, Class, Order, Species))  %>% 
  gather (-c(ASV_ID, Genus, Family), key=sampleID, value = ASV_counts)  %>%
  left_join(metaM0, by="sampleID") %>% 
  filter (ASV_counts!=0)  %>% 
  group_by( Genus,ASV_ID )  %>% 
  tally ()  %>%  
left_join(tax_table (ps_Glo) %>%  
            data.frame () %>%  
            as_tibble(rownames = "ASV_ID") %>%  select (!Genus), by="ASV_ID")   %>% 
  replace_na(list (Genus="unidentified")) %>% 
  replace_na(list (Family="unidentified")) %>% 
  replace_na(list (Order="unidentifiedOrder")) %>% 
  ggplot (aes(area= n, label= n,fill = Genus , subgroup= Family, subgroup2=Order)) +
  geom_treemap () 
  
 p  +  geom_treemap_subgroup_text(fontface = "italic", 
                                   colour = "white", place = "centre",
                                     grow = TRUE) + 
    scale_fill_manual(values = c( "unidentified" ="#C7EAE5", 
                                  "Archaeospora"  = "#287D8EFF" , 
                                  "Acaulospora" =  "#C1A363" , 
                                  "Funneliformis" = "#F6E8C3", 
                                  "Cetraspora"  = "#DFC27D", 
                                  "Claroideoglomus" =  "#20A386FF", 
                                  "Glomus" = "#80CDC1" , "Paraglomus" = "#35978F", 
                                  "Scutellospora"= "#01665E" ), name = "AMF genus") +
   theme(legend.text=element_text(size=20, face = "italic"), legend.title = element_text(size =24))
  #   annotate(geom = "text", x = 0.25, y = 0.25, label = "The annotation") +
  # geom_treemap_text()  +
  # scale_x_continuous(breaks=NULL, limits = c(0, 1), labels=NULL, name=NULL) +
  # scale_y_continuous(breaks =NULL, limits = c(0, 1), labels=NULL, name=NULL)+
   # falls doch eine Beschrifung der boxen erfolgen soll. 
  #Außerdem habe ich die treemap mit ASvs und mit Anzahl der links abgespeichert für Vergleiche

  





  

```
## Interaction niche overlap

Non-metric multidimensional scaling (NMDS) ordination of the Raup-Crick distances of the AMF core communities of the treatments indicates that the AMF communities of the plants from the Poaceae and Plantaginaceae clustered somewhat together, whereas the plant species from the Asteraceae separated from each other and the Poaceae and Plantaginaceae (Fig. \@ref(fig:NMDS-raup-core)).
However, testing of the similarity of the centroids by PERMANOVA shows that the AMF core communities did not vary significantly among plant species (PERMANOVA R^2^ = `r round (permanova_raup_core$aov.tab$R2[1],2)`, *p* = `r permanova_raup_core$aov.tab$"Pr(>F)"[1]`), therefore contradicting parts of hypothesis 2 that states that some specialists employ complementarity of resource use as strategy of specificity. 
Additional testing of the homogeneity of the multivariate dispersion (PERMDISP) disclosed the differences in dispersion among the treatments (PERMDISP F = `r round (permdisp_raup_core$tab$F[1], 2)`, *p* = `r permdisp_raup_core$tab$"Pr(>F)"[1]`). A pairwise PERMANOVA and PERMDISP test revealed that the differences among AMF core communities among plant families (e.g., Plantaginaceae versus Asteraceae) as indicated by the NMDS were a result of differences in dispersion (Tables \@ref(tab:PERMANOVA-raup-distance) and \@ref(tab:PERMDISP-raup)).




```{r NMDS-raup-core, fig.cap= "Non-metric multidimentional scaling (NMDS) ordination based on Raup-Crick distances between core AMF communities. Shapes symbolise plant families, with a larger symbol denoting the centre for each treatment. The Raup-Crick distances account for the highly different AMF richness among the samples. Dots are colored by treatment." ,  fig.height=8, fig.width=10}

# core species #####
ps_Glo_core <- taxa_core (ps_Glo,frequency = 0.6, treatment = "PlaSpe") #see MPD, I tested diff abundance treshhold, results stays the same
ps_Glo_core  <-  prune_samples(sample_sums(ps_Glo_core)>0, ps_Glo_core)#remove empty samples

#as data.frame for vegdist function
df  <- as.data.frame (otu_table(ps_Glo_core))
df <- t(df)

#Calculate distance matrix##
dm  <-vegdist(df, method = "raup" ) #raupcrick distance for samples that have diff abundances and species richness see Beckett
#dm  <-vegdist(df, method = "bray", binary = T ) #sorensen


# Determine best number of dimensions###
# function NMDS.scree() 
# performs NMDS for 1-10 dimensions and plots the nr of dimensions vs the stress 
# - code changed after https://ourcodingclub.github.io/tutorials/ordination/

# NMDS.scree <- function(x) { #where x is the name of the data frame variable
#   plot(rep(1, 10), replicate(10, metaMDS(x, autotransform = F,trace =F, k = 1)$stress), xlim = c(1, 10),ylim = c(0, 0.30), xlab = "Number of Dimensions", ylab = "Stress", main = "NMDS scree plot")
#   for (i in 1:10) {
#     points(rep(i + 1,10),replicate(10, metaMDS(x, autotransform = F, k = i + 1)$stress))
#   }
# }
# 
# # Get scree plot to determine stress vs dimension in NMDS
# ScreeNMDS  <-NMDS.scree(dm)
# 
#Run NMDS
NMDS_dm  <- metaMDS (dm, distance = dm, trymax=1000, k =5, trace=F) #trace = F , then it stays quiet, k is number of dimension
#NMDS more robust than methods that include the magnitude of the distances, 
# get scores
scrs <- scores (NMDS_dm, display = "sites")
scrs <-as.data.frame(scrs) %>%  as_tibble(rownames = "sampleID") %>%  left_join (metaM0)
center <- aggregate(cbind (NMDS1, NMDS2) ~PlantSpeciesfull, data = scrs, FUN= mean) %>% 
  rename("NMDS1" = "cNMDS1", "NMDS2" = "cNMDS2") %>% 
  left_join (metaM0 %>%  select (PlantSpeciesfull, PlantFamily ) %>% unique ()) %>% 
       mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control"))

segs <- left_join (scrs, center) %>% 
       mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control"))


#Plot NMDS in ggplot using phyloseq
col  <- brewer.pal(8,  "Accent") # use all 8 colors from  palette
new_pal  <- colorRampPalette(col)  #then use with col = new_pal (21) for 21 different colors


p <- ggplot (segs , aes (x = NMDS1, y = NMDS2, color = PlantSpeciesfull, shape = PlantFamily))  + 
  geom_segment(segs, mapping = aes (xend = cNMDS1, yend = cNMDS2)) + 
  geom_point(data = segs, mapping =aes (x = NMDS1, y= NMDS2), size = 3) + 
  geom_point (data = center , aes (x= cNMDS1, y = cNMDS2), size = 5)



p  + 
  guides (color = guide_legend (order =2,  title = "Plant species", 
                                label.theme = element_text(face = "italic", family = "sans", size = 11),ncol = 1), 
          shape = guide_legend(order=1, title = "Plant family",legend.position = "bottom" ))  +
  scale_color_manual(values = new_pal(21))  + 
  theme_bw() + 
   # stat_ellipse(level=0.95) +
  scale_shape_manual (values= c(16,17, 18, 3,12,8 )) +
  annotate ("text", x= 0.2, y=0.4, label = "Stress = 0.11") #annotation is added by hand here, see NMDS_dm$stress
      # NMDS_dm$stress
#the stress value reflects how well the ordination summarizes the observed distances among the samples.
#stress value >0.2 poor and might not be interpretable, values <0.1 good, between 0.1 and 0.2 usable but see dexter et all - stress depends on samples etc, 
#some of the distances might be misleading

##Test ecological null model
# result<-oecosimu(comm = df, method = "quasiswap", 
#                  nestfun = metaMDS, autotransform = FALSE, k = 5, #add dimension
#                  distance = "raup", nsimul = 1000,  statistic = "stress", #add distance measure
#                  alternative = "less", trace = FALSE, maxit = 200, 
#                  trymax = 50, sratmax = 0.9999999)

# result$oecosimu$statistic # stress of my data NMDS
# result$oecosimu$means
# result$oecosimu$z
# result$oecosimu$pval #this is relevant for reporting

# Similar to a permutation test  - in oecosimu() the values of the statistic are computed using data generated from one of the Null models
# How MANY of the stress values generated using the Null model of the data are less than or equal to the observed stress value (OR: alternative = "two.sided" (=different from), alternative = "greater"(or greater than or equal to))   .
# Plot the stress values of simulated NMDS
#Plot quick and dirty to check
# hist(as.vector(result$oecosimu$simulated), xlim = c(0,max(result$oecosimu$simulated)+.05), xlab = "Stress value",ylab = "Frequency observed", main = "", breaks = 7)
# abline(v = result$oecosimu$statistic, col = "red", lty = 2) 


# #Pretty ggplot  stress values randomised vs stress observed
# simVector<-as.data.frame (as.vector(result$oecosimu$simulated))
# simVector<-cbind(simVector,seq(1:1000))
# 
# stresshisto <- ggplot(simVector,aes(x=as.vector(result$oecosimu$simulated))) +  
#   geom_histogram(col="black",size=.25) +
#   theme_minimal() + 
#   xlim(c(0.07, .2)) + ylim(c(0,600)) + #change limits as fitting to stress value
#   geom_segment(aes(x = result$oecosimu$statistic, y = 0, xend = result$oecosimu$statistic), yend = 600,linetype=2,color = "red",size=.5) + #change limits of plot as needed
#   labs(x="Stress value")  +
#   labs(y="Frequency observed")
# 

pair.perm_raup_core <- read_rds ("resultsCh2/pair_perm_raup_core.rds")
permdisp_pairs_raup_core <- read_rds ("resultsCh2/permdisp_pairs_raup_core.rds")
permanova_raup_core <- read_rds ("resultsCh2/permanova_raup_core.rds")
permdisp_raup_core <- read_rds ("resultsCh2/permdisp_raup_core.rds")

  

```

```{r NMDS-uf-core, fig.cap= "Non-metric multidimensional scaling (NMDS) ordination based on UniFrac distances between core AMF communities. Shapes symbolise plant families, with a larger symbol denoting the centre for each treatment. Unifrac distances measure the phylogenetic distance between the AMF taxa between two sample pairs. Dots are colored by treatment",  fig.height=8, fig.width=10 }

# core species #####
# ps_Glo_core <- taxa_core (ps_Glo,frequency = 1/2,  treatment = "PlaSpe")
# ps_Glo_core  <-  prune_samples(sample_sums(ps_Glo_core)>0, ps_Glo_core)#remove empty samples
# 
# #as data.frame for vegdist function
# df  <- as.data.frame (otu_table(ps_Glo_core))
# df <- t(df)

#Calculate distance matrix##
dm  <-UniFrac(ps_Glo_core, weighted = F ) #UniFrac

# tested hellinger transformation - NMDS are identical...
# Determine best number of dimensions###
# function NMDS.scree() 
# performs NMDS for 1-10 dimensions and plots the nr of dimensions vs the stress 
# - code changed after https://ourcodingclub.github.io/tutorials/ordination/

# NMDS.scree <- function(x) { #where x is the name of the data frame variable
#   plot(rep(1, 10), replicate(10, metaMDS(x, autotransform = F, k = 1)$stress), xlim = c(1, 10),ylim = c(0, 0.30), xlab = "Number of Dimensions", ylab = "Stress", main = "NMDS scree plot")
#   for (i in 1:10) {
#     points(rep(i + 1,10),replicate(10, metaMDS(x, autotransform = F, k = i + 1)$stress))
#   }
# }
# 
# # Get scree plot to determine stress vs dimension in NMDS
# ScreeNMDS  <-NMDS.scree(dm)

#Run NMDS
NMDS_dm  <- metaMDS (dm, distance = dm, trymax=1000, k =5, trace=F) #trace = F , then it stays quiet, k is number of dimension
#NMDS more robust than methods that include the magnitude of the distances, 

# get scores prepare tibble 
scrs <- scores (NMDS_dm, display = "sites")
scrs <-as.data.frame(scrs) %>%  as_tibble(rownames = "sampleID") %>%  left_join (metaM0)

# get centroids
center <- aggregate(cbind (NMDS1, NMDS2) ~PlantSpeciesfull, data = scrs, FUN= mean) %>%  
  rename("NMDS1" = "cNMDS1", "NMDS2" = "cNMDS2") %>% 
  left_join (metaM0 %>%  select (PlantSpeciesfull, PlantFamily ) %>% unique ()) %>%      mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control")) 
segs <- left_join (scrs, center) %>%      mutate (PlantFamily = str_replace(PlantFamily, "Soil","Soil control")) 




#Plot NMDS in ggplot using phyloseq
col  <- brewer.pal(8,  "Accent") # use all 8 colors from  palette
new_pal  <- colorRampPalette(col)  #dann mit col = new_pal (21) verwenden


p <- ggplot (segs , aes (x = NMDS1, y = NMDS2, color = PlantSpeciesfull, shape = PlantFamily))  + 
  geom_segment(segs, mapping = aes (xend = cNMDS1, yend = cNMDS2)) + 
  geom_point(data = segs, mapping =aes (x = NMDS1, y= NMDS2), size = 3) + 
  geom_point (data = center , aes (x= cNMDS1, y = cNMDS2), size = 5)

p  +  guides (color = guide_legend (order =2,  title = "Plant species", 
                                    label.theme = element_text(face = "italic", family = "sans", size = 11),ncol = 1), 
              shape = guide_legend(order=1, title = "Plant family",legend.position = "bottom" ))  +
  scale_color_manual(values = new_pal(21))  + 
  theme_bw() + 
 # stat_ellipse(level=0.95) +
  scale_shape_manual (values= c(16,17, 15, 3,10,8 )) +
  annotate ("text", x= 0.2, y=0.5, label = "Stress = 0.08") 
# NMDS_dm$stress
#the stress value reflects how wel the ordination summarizes the observed distances among the samples.
#stress value >0.2 poor and might be uninterpretable, values <0.1 good, between 0.1 and 0.2 useable but see dexter et all - stress depends on samples etc, 
#some of the distances might be misleading

# ##Test ecological null model
# # Function that calculates NMDS on Unifrac distances of randomised community data
#                      
#  comdist.is  <- function (x) {
#   metaMDS( as.matrix (UniFrac(phyloseq_randomize(x, null_model = "phylogeny.pool"), weighted =F)), k=5)$stress  #change number of dimensions k #x is a phyloseq object
# }
 #get the stress for 1000 runs of NMDS 
 #null_stress <- replicate (1000, comdist.is(ps_Glo_core))
 
 #calculate how often stress of null model NMDS are smaller than observed stress of null model
 # p_value  <- 
 #  null_stress %>%  
 #  as_tibble() %>%  
 #  filter (value < NMDS_dm$stress) %>% 
 #  tally () %>% 
 #   mutate (p_value = n /1000)



# 
# 
# # Plot the stress values of simulated NMDS
# #Plot quick and dirty to check
# hist(null_stress, xlim = c(0.05,max(null_stress)+.05), xlab = "Stress value",ylab = "Frequency observed", main = "", breaks = 10)
#  abline(v = NMDS_dm$stress, col = "red", lty = 2) 

# #Replot in ggplot  stress values randomised vs 
# simVector<-as.data.frame (null_stress)
# simVector<-cbind(simVector,seq(1:1000))
# 
# stresshisto <- ggplot(simVector,aes(x=null_stress)) +  
#   geom_histogram(col="black",size=.25) +
#   theme_minimal() + 
#   xlim(c(0.05, .17)) + ylim(c(0,600)) + 
#   geom_segment(aes(x = NMDS_dm$stress, y = 0, xend = NMDS_dm$stress), yend = 600,linetype=2,color = "red",size=.5) + 
#   labs(x="Stress value")  +
#   labs(y="Frequency observed")

pair.perm_uf_core  <- read_rds ("resultsCh2/pair_perm_uf_core.rds")

permdisp_pairs_uf_core  <- read_rds ("resultsCh2/permdisp_pairs_uf_core.rds")

permanova_uf_core <- read_rds ("resultsCh2/permanova_uf_core.rds")
permdisp_uf_core <- read_rds ("resultsCh2/permdisp_uf_core.rds")

  

```



Analogously, NMDS ordination on the Unifrac distances of the AMF core communities suggests higher phylogenetic similarity among the AMF communities detected in the Poaceae, Plantaginaceae and soil samples, and some separation between the AMF communities determined in the other plant families (Fig. \@ref(fig:NMDS-uf-core)).
PERMANOVA testing implies that the AMF core communities from different groups were not significantly phylogenetically different from each other (PERMANOVA R^2^ =`r round(permanova_uf_core$aov.tab$R2[1],2)`, *p* =`r  permanova_uf_core$aov.tab$"Pr(>F)"[1]`, and Table \@ref(tab:PERMANOVA-uf-core)), but differed in their multivariate dispersion (PERMDISP F = `r round (permdisp_uf_core$tab$F[1], 2)`, *p* = `r permdisp_uf_core$tab$"Pr(>F)"[1]`). Table \@ref(tab:PERMDISP-uf-core) shows the results of the pairwise comparison.



### Permanova tables

```{r PERMANOVA-raup-distance , include =T,  tab.cap ="Pairwise permutational multivariate analysis of variance (PERMANOVA) of the Raup-Crick distances. PERMANOVA tests if the centroids and variances of the pairs are equivalent. In conjunction with a non-significant PERMDISP of the same pair, a significant PERMANOVA implies unequal centroids. f = F-statistic (pseudo-F, a measure of effect size), p = p-value.", tab.id = "PERMANOVA-raup-distance", label = "PERMANOVA-raup-distance" }
options(knitr.kable.NA = "")

pair.perm_raup_core <- read_rds ("resultsCh2/pair_perm_raup_core.rds")
##SEE PERMANOVA.R script 
#might help to run the permanova outside of the markdown - something interferes sometimes.
#it helped to re install vegan first, then phyloseq.

#
#R2 column: 
#we can/ can not reject the null hypothesis that our plant species AMF communities have the same centroid.
#for p< 0.05 reject
#for p>0.05 con not reject (centroids are the same)
#the global effect of plant species is significant
#  permanova_raup_core

#pairwise permanova
# pair.perm_raup_core
#
#R2 gives me the effect size.. x% of variation explained by grouping
#Only the pairs with p value <0.05
# sign_permdisp_all  <-   permdisp_pairs_raup_core$pairwise$permuted  %>% 
#   as_tibble(rownames = "pairs") %>% 
#   filter (value <0.05 ) %>%
#   mutate (value =round (value,3))  %>% 
#   dplyr::rename ("p-value" = "value") %>% 
#   data.frame()
table  <-
  pair.perm_raup_core$F.value  %>%  as_tibble(rownames = "Plant")  %>%
pivot_longer(names_to = "Pl1", values_to = "valueF", cols = c(-Plant)) %>% 
  drop_na(valueF) %>% left_join ((pair.perm_raup_core$p.value  %>% 
                                   as_tibble(rownames = "Plant")  %>%
    pivot_longer(names_to = "Pl1", values_to = "value", cols = c(-Plant)) %>% 
    drop_na(value)), by = c("Plant" = "Plant", "Pl1" ="Pl1")) %>% 
  mutate (valueF =round (valueF, 2), value= round (value,3))  %>%  
  add_column (F = "F = ")   %>% mutate (FValue= str_c(F,valueF))  %>% 
  add_column (p= "p = ") %>%  mutate (Pval = str_c(p, value))  %>% 
  add_column (sym = "; ")  %>%     
  mutate (Zelle = str_c(FValue, sym,Pval)) %>%   
  select (Plant, Pl1, Zelle) %>% 
  pivot_wider(names_from = "Pl1", values_from = "Zelle") %>% 
flextable  ()  %>% 
    fontsize(size =5, part = "body") %>% 
    fontsize(size =7, part = "header") %>% 
    fontsize(size =6, part = "footer") %>% 
    add_footer_lines (values  = "Significant pairs (p < 0.05) are in bold.") %>%  
  autofit()

table

```

```{r PERMDISP-raup  , include =T, tab.cap = "Pairwise permutational multivariate analysis of dispersion (PERMDISP) of Raup-Crick distances. PERMDISP tests the equality of the variances, significant (p<0.05, in bold) values indicate pairs that differ in variance. F = F-statistic, p = p-value.", tab.id = "PERMDISP-raup", label = "PERMDISP-raup" }
options(knitr.kable.NA = "")

permdisp_pairs_raup_core <- read_rds ("resultsCh2/permdisp_pairs_raup_core.rds")
#Check that variance homogeneity assumptions hold (to ensure the reliability of the results)
#Permuted multivariate analysis of beta-dispersion (PERMDISP)
# The vegan function betadisper() performs PERMDISP. This test is different from the others in that it specifically tests for differences in the spread (dispersion, variability) among groups.
# 
# Therefore, if you use this test in combination with one of the other three, you will be able to tease apart whether groups of communities are different because they have different centroids or different spreads. For example, if PERMANOVA yields a significant difference, but PERMDISP does not, you can safely say that the distinction between groups can be attributed to differences in their centroid. Ordinations are often a good way to visually support and summarize these findings.

#permdisp_raup_core
# 
# permdisp_pairs_raup_core$pairwise$permuted
#see extra document PEMANOVA!!!


Table_permdisp_raup_core  <-
unlist (round (permdisp_pairs_raup_core$pairwise$permuted, 2)) %>%  
  as_tibble(rownames = "pair")  %>%  
  separate(pair, c("Plant", "Pl1"),"-" ) %>% 
  left_join (
   ( unlist (round (permdisp_pairs_raup_core$statistic, 2)) %>%  
               as_tibble(rownames = "pair")  %>%  
               separate(pair, c("Plant", "Pl1"),"-" ) %>% 
              drop_na (Pl1) %>%  add_column (t = "F = ") %>% 
      mutate (tval = str_c(t, value)) %>%  
      mutate (Pl1 = str_replace (Pl1," \\(t\\)", ""))  %>% 
      select (Plant, Pl1, tval)), by = c( "Plant" = "Plant", "Pl1" = "Pl1")) %>% 
  add_column (sym = "; ")  %>% 
  add_column (p= "p = ") %>%  mutate (Pval = str_c(p, value))  %>% 
  mutate (Zelle = str_c(tval, sym,Pval)) %>%   
  select (Plant, Pl1, Zelle) %>% 
  pivot_wider(names_from = "Pl1", values_from = "Zelle") %>% 
  flextable ()  %>% 
  fontsize(size =5, part = "body") %>% 
    fontsize(size =7, part = "header") %>% 
    fontsize(size =6, part = "footer") %>% 
  add_footer_lines (values = "Significant pairs (p < 0.05) are in bold. t-test results and p-values are given per pair. ") %>%  
  autofit ()
 
Table_permdisp_raup_core

```


```{r PERMANOVA-uf-core, include =T, tab.cap ="Pairwise permutational multivariate analysis of variance (PERMANOVA) of the Unifrac distances. PERMANOVA tests if the centroids and variances of the pairs are equivalent. In conjunction with a non-significant PERMDISP of the same pair, a significant PERMANOVA implies unequal centroids. f = F-statistic (pseudo-F, a measure of effect size), p = p-value.", tab.id = "PERMANOVA-uf-core", label = "PERMANOVA-uf-core" }
options(knitr.kable.NA = "")

pair.perm_uf_core  <- read_rds ("resultsCh2/pair_perm_uf_core.rds")

#Table of PERMANOVA results
pair.perm_uf_core$F.value  %>%  as_tibble(rownames = "Plant")  %>%
pivot_longer(names_to = "Pl1", values_to = "valueF", cols = c(-Plant)) %>% 
  drop_na(valueF) %>% 
  left_join ((pair.perm_uf_core$p.value  %>%  
             as_tibble(rownames = "Plant")  %>%
            pivot_longer(names_to = "Pl1", values_to = "value", cols = c(-Plant)) %>% 
            drop_na(value)), by = c("Plant" = "Plant", "Pl1" ="Pl1")) %>% 
  mutate (valueF =round (valueF, 2), value= round (value,3))  %>%  
  add_column (F = "F = ")   %>% mutate (FValue= str_c(F,valueF))  %>% 
  add_column (p= "p = ") %>%  mutate (Pval = str_c(p, value))  %>% 
  add_column (sym = "; ")  %>%     
  mutate (Zelle = str_c(FValue, sym,Pval)) %>%   
  select (Plant, Pl1, Zelle) %>% 
  pivot_wider(names_from = "Pl1", values_from = "Zelle") %>% 
flextable  ()  %>% 
    fontsize(size =5, part = "body") %>% 
    fontsize(size =7, part = "header") %>% 
    fontsize(size =6, part = "footer") %>% 
    add_footer_lines (values  = "Significant pairs (p < 0.05) are in bold.") 


```

```{r PERMDISP-uf-core, include =T,  tab.cap = "Pairwise permutational multivariate analysis of dispersion (PERMDISP) of UniFrac distances. PERMDISP tests the equality of the variances, significant (p<0.05, in bold) values indicate pairs that differ in variance. F = F-statistic, p = p-value.", tab.id = "PERMDISP-uf-core", label = "PERMDISP-uf-core" }
options(knitr.kable.NA = "")

permdisp_pairs_uf_core  <- read_rds ("resultsCh2/permdisp_pairs_uf_core.rds")
#Table of PERMDISP results
Table_permdisp_uf_core  <-
  unlist (round (permdisp_pairs_uf_core$pairwise$permuted, 2)) %>%  
  as_tibble(rownames = "pair")  %>%  
  separate(pair, c("Plant", "Pl1"),"-" ) %>% 
  left_join (
    ( unlist (round (permdisp_pairs_uf_core$statistic, 2)) %>%  
        as_tibble(rownames = "pair")  %>%  
        separate(pair, c("Plant", "Pl1"),"-" ) %>% 
        drop_na (Pl1) %>%  add_column (t = "F = ") %>% 
        mutate (tval = str_c(t, value)) %>%  
        mutate (Pl1 = str_replace (Pl1," \\(t\\)", ""))  %>% 
        select (Plant, Pl1, tval)), by = c( "Plant" = "Plant", "Pl1" = "Pl1")) %>% 
  add_column (sym = "; ")  %>% 
  add_column (p= "p = ") %>%  mutate (Pval = str_c(p, value))  %>% 
  mutate (Zelle = str_c(tval, sym,Pval)) %>%   
  select (Plant, Pl1, Zelle) %>% 
  pivot_wider(names_from = "Pl1", values_from = "Zelle")  %>% 
  flextable ()  %>% 
    fontsize(size =5, part = "body") %>% 
    fontsize(size =7, part = "header") %>% 
    fontsize(size =6, part = "footer") %>% 
  add_footer_lines (values = "Significant pairs (p < 0.05) are in bold.") 

Table_permdisp_uf_core

```









```{r plot-relreads-perPlant, fig.cap = "Relative read abundances of the AMF genera in each treatment.", fig.height= 6, fig.width=10}



#Plot unique ASVs per plant####
  # Verteilung der Glo genera per plant species 
# p1  <-  ASV_table_Glo  %>%  
#     select(-c(Kingdom, Phylum, Class, Order, Species))  %>% 
#     gather (-c(ASV_ID, Genus, Family), key=sampleID, value = ASV_counts)  %>%
#     left_join(metaM0, by="sampleID") %>% 
#     filter (ASV_counts!=0)  %>% 
#     group_by (ASV_ID, PlantSpeciesfull, Genus) %>% 
#     tally () %>%
#     group_by(Genus, PlantSpeciesfull )  %>% 
#     tally () %>% 
#   replace_na(list (Genus="unidentified"))   %>% 
#     left_join (meannumberASVsper_species, by = "PlantSpeciesfull")  %>% 
#     ggplot (aes(x=reorder (PlantSpeciesfull,-mean_n_ASV_per_species), y= n, fill=Genus))  +
#     geom_bar(position="stack", stat ="identity") 

# p1<-
#   p1+ theme_light()+ 
#   coord_flip () +
#   ylab("Unique AMF ASVs per plant species") +
#   xlab ("Plant species") +
#   theme_light () +
#   theme(axis.text.y= element_text(family= "sans", face= "italic", size = 12)) +
#   theme (axis.text.x=element_text(family= "sans", size = 12))  +
  # theme (axis.title = element_text(family = "sans", size = 14 ),  
  #        legend.title=element_text(size=13), 
  #        legend.text=element_text(size=11, face ="italic")) +
  #   scale_fill_manual(values = c( "unidentified" ="#C7EAE5", "Archaeospora"  = "#287D8EFF" , 
  #                                 "Acaulospora" =  "#C1A363" , 
  #                                 "Funneliformis" = "#F6E8C3", "Cetraspora"  = "#DFC27D", 
  #                                 "Claroideoglomus" =  "#20A386FF", 
  #                                 "Glomus" = "#80CDC1" , "Paraglomus" = "#35978F", 
  #                                 "Scutellospora"= "#01665E" ), name = "AMF genus"    )  
  p2   <-
  ASV_table_Glo   %>%
  select(-c(Kingdom, Phylum, Class, Order, Species, Family))  %>%
  gather (-c(ASV_ID, Genus), key=sampleID, value = ASV_counts)  %>%
  group_by (sampleID, Genus)  %>%
  summarise (ASV_sum_per_sample = sum(ASV_counts)) %>%
replace_na(list (Genus="unidentified"))   %>%
  left_join (metaM0, by = "sampleID")  %>%
  group_by (PlantSpeciesfull, Genus)  %>%
  summarise (mean_ASV_count_per_species = mean (ASV_sum_per_sample))  %>%
  left_join (meannumberASVsper_species, by = "PlantSpeciesfull")  %>%
  ggplot (aes(x=reorder (PlantSpeciesfull,-mean_n_ASV_per_species),
              y= mean_ASV_count_per_species, fill=Genus))  +
  geom_bar(position="fill", stat ="identity")

p2  <-
  p2 + coord_flip () +
  ylab("Relative abundance of ASV reads (%)") +
  theme_light () +
  theme(axis.text.y= element_text(family= "sans", face= "italic", size = 12)) +
 theme (axis.text.x=element_text(family= "sans", size = 12))  +
  theme (axis.title = element_text(family = "sans", size = 14 ),
         legend.title=element_text(size=13),
         legend.text=element_text(size=11, face = "italic"),
         axis.title.y = element_blank()) +
  scale_fill_manual(values = c( "unidentified" ="#C7EAE5", "Archaeospora"  = "#287D8EFF" ,
                                "Acaulospora" =  "#C1A363" ,
                                "Funneliformis" = "#F6E8C3", "Cetraspora"  = "#DFC27D",
                                "Claroideoglomus" =  "#20A386FF",
                                "Glomus" = "#80CDC1" , "Paraglomus" = "#35978F",
                                "Scutellospora"= "#01665E" ) , name = "AMF genus"   )  +
  scale_y_continuous(labels = scales::percent)+
  scale_x_discrete(labels = NULL)

# ggarrange (p1,NULL, p2, labels = c("A","B", ""), nrow = 1, ncol =3, widths =  c(2,0.07,1.2), legend = "bottom", common.legend = T)

p2
  
```

